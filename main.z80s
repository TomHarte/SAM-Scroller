LINE:		EQU 249
STATUS:		EQU 249

LMPR:		EQU 250
HMPR:		EQU 251
VMPR:		EQU 252
BORDER:		EQU 254

EXECPAGE:	EQU 24
SETUPPAGE:	EQU 14

INC "per_buffer_layout.z80s"

	ORG 0
	DUMP EXECPAGE, 0
	AUTOEXEC

	; This program does not use interrupts.
	di

	; Disable display until setup is complete.
	ld a, %10000000
	out (BORDER), a

	; Establish line interrupts at line 191, which will be polled for later.
	ld a, 191
	out (LINE), a

	;
	; The SAM being what it is, execution will actually begin with this code in
	; the upper page.
	;
	; But that's convenient for taking advantage of the setup code — put that
	; initially into the lower page and give it a modified return address.
	;
	ld a, %00100000 + SETUPPAGE
	out (LMPR), a
	ld de, @+fix_page + 0x8000
	jp setup_per_screen_code

@fix_page:
	; Page self to lower page and proceed with execution from there.
	ld a, %00100000 + EXECPAGE
	out (LMPR), a

@redraw_all:
	; Do a full redraw at the current scroll position.
	ld de, @+enter_loop
	jp @+reset_scrolling

@enter_loop:
	; Reenable the display.
	ld a, %00000000
	out (BORDER), a

;
; Initial setup tasks are done now.
;

@draw_scene:

	; Check for keypresses. TODO: actual physics, gameplay, etc.

IF BORDER_PROFILING
	ld a, %00000000
	out (BORDER), a
ENDIF

	call run_physics

@redraw:
IF BORDER_PROFILING
	ld a, %00000010
	out (BORDER), a
ENDIF

	; Put next target buffer into the upper page.
	ld a, (@+scroll_offset)
	out (HMPR), a

	; Don't OR anything into the dirty map if there was no scroll.
	ld a, (@+scroll_change)
	or a
	jp z, @+end_logic

	;
	; OR per-page dirty bits with the fixed list to produce a composite diff.
	;
	ld de, DIRTY_FLAGS + FLAGS_SIZE
	ld hl, (@+diff_address)

	; The above assumes a scroll to the right; adjust for a scroll to the left.
	rra
	jr nc, @+or_flags

	ld bc, 3
	add hl, bc

@or_flags:
@or_loop: EQU FOR 51
	dec e
	dec hl

	ld a, (de)
	or (hl)
	ld (de), a
NEXT @or_loop

	; Record no scroll as pending.
	xor a
	ld (@+scroll_change), a

@end_logic:

	;
	; Wait for start of lower border.
	;
@wait:
	in a, (STATUS)
	rra
	jr c, @-wait
	;
	; Display is now beginning the first line of lower border.
	;

IF BORDER_PROFILING
	ld a, %00000001
	out (BORDER), a
ENDIF

	; TODO: do keyboard stuff at end of frame, not top; check for a required scroll
	; and do the flag ORing before updating VMPR, thereby avoiding the bottom-line tear.

	; Switch to displaying whatever is the correct screen.
	ld a, (@+next_vmpr)
	out (VMPR), a

IF BORDER_PROFILING
	ld a, %00000100
	out (BORDER), a
ENDIF

	; Grab map address and set diffs list pointer.
	ld ix, (@+map_address)

	;
	; Segue into tile drawing.
	;
	ld de, @+tiles_drawn
	jp draw_tiles
@tiles_drawn:

	;
	; Set a meaningful SP for code below.
	;
	ld sp, 0

IF BORDER_PROFILING
	ld a, %00000101
	out (BORDER), a
ENDIF

	;
	; Add hero sprite.
	;
	call draw_hero_sprite

	;
	; Set the page just drawn to as next to display
	;
	ld a, (@+scroll_offset)
	add a, %01100000
	ld (@+next_vmpr), a

;
; Loop for end of frame
;
	jp @-draw_scene


;
; Scrolls the display one position to the left.
;
@scroll_left:
	;
	; Check that total offset is greater than 0; if so then subtract 1
	; and continue. Otherwise return early.
	;
	ld hl, (@+total_x)
	ld a, h
	or l
	ret z

	dec hl
	ld (@+total_x), hl

	; Record that a scroll left happened.
	ld a, 1
	ld (@+scroll_change), a

	;
	; Subtract two from scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	dec a
	dec a
	and 15
	ld (@+scroll_offset), a

	;
	; Update map pointer if the scroll offset just decremented to 0.
	;
	ret nz

	ld hl, (@+map_address)
	ld bc, -12
	add hl, bc
	ld (@+map_address), hl

	ld hl, (@+diff_address)
	ld bc, -3
	add hl, bc
	ld (@+diff_address), hl

	ret

;
; Scrolls the display one position to the right.
;
@scroll_right:
	;
	; Check that total offset is less than the map size; if so then add 1
	; and continue. Otherwise return early.
	;
	ld hl, (@+total_x)
	ld bc, (((diffs - map) / 12) - column_count) * 8
	scf
	ccf
	sbc hl, bc
	ret z

	add hl, bc
	inc hl
	ld (@+total_x), hl

	; Record that a scroll right happened.
	ld a, 2
	ld (@+scroll_change), a

	;
	; Add two to scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	inc a
	inc a
	and 15
	ld (@+scroll_offset), a

	;
	; Do not update map pointer if the scroll offset didn't just increment from 0.
	;
	; Logic here is that offset 1 is the map at offset 0 but moved one position to
	; the left. Therefore the step up from 0 is the point at which the far extent
	; of the map changes.
	;
	ld a, d
	or a
	ret nz

	; Add 12 to map address to move one column along.
	; Correspondingly add 3 to the diff address.
	ld hl, (@+map_address)
	ld bc, 12
	add hl, bc
	ld (@+map_address), hl

	ld hl, (@+diff_address)
	ld bc, 3
	add hl, bc
	ld (@+diff_address), hl

	ret

;
; Performs a full redraw of all video buffers.
;
@reset_scrolling:
	ld (@+return+1), de

	; Seed all buffers.
	ld a, 16
	ld (@+scroll_offset), a
@seed_tiles:
	ld a, (@+scroll_offset)
	or a
	jr z, @+end_seed
	dec a
	dec a
	ld (@+scroll_offset), a
	out (HMPR), a

	ld a, 0x3c
	ld hl, DIRTY_FLAGS
	ld b, FLAGS_SIZE
@flags_loop:
	ld (hl), a
	inc l
	dec b
	jr nz, @-flags_loop

	ld ix, (@+map_address)
	ld de, @-seed_tiles
	jp draw_tiles

@end_seed:
	xor a
	ld (@+scroll_offset), a

@return:
	jp 1234


run_physics:
	;
	; Vertical.
	;
	ld hl, (@+sprite_current+Y_OFFSET)		; HL = current, BC = previous, and update in-memory copy of previous.
	ld bc, (@+sprite_previous+Y_OFFSET)
	ld (@+sprite_previous+Y_OFFSET), hl

	or a
	sbc hl, bc
	ld d, h
	ld e, l

	sra d
	rr e
	sra d
	rr e
	sra d
	rr e
	sra d
	rr e
	sra d
	rr e

	or a
	sbc hl, de

	ex de, hl
	ld hl, (@+sprite_current+Y_OFFSET)
	add hl, de						; Add difference to HL.

	ld bc, GRAVITY_STRENGTH			; Add some gravity.
	add hl, bc

	; Reset on-ground flag.
	ld a, (@+hero_flags)
	and ~FLAG_ON_GROUND
	ld (@+hero_flags), a

	; Test for bounds of screen.
	ld a, h
	cp START_Y + 192 - 24
	jr c, @+test_top

	; If here: is on ground.
	ld hl, (START_Y + 192 - 24) << 8
	ld a, (@+hero_flags)
	or FLAG_ON_GROUND
	ld (@+hero_flags), a

	jr @+store_y

@test_top:
	cp 8				; This is a magic constant related to how far I think the hero could ever tunnel.
						; TODO: verify, and don't retain as a magic constant.
	jr nc, @+store_y
	ld hl, 8 << 8

@store_y:
	ld (@+sprite_current+Y_OFFSET), hl

	;
	; Horizontal.
	;
	ld hl, (@+sprite_current+X_OFFSET)		; HL = current, BC = previous, and update in-memory copy of previous.
	ld bc, (@+sprite_previous+X_OFFSET)
	ld (@+sprite_previous+X_OFFSET), hl

	or a
	sbc hl, bc
	ld d, h
	ld e, l

	sra d
	rr e
	sra d
	rr e
	sra d
	rr e
	sra d
	rr e

	or a
	sbc hl, de

	ex de, hl
	ld hl, (@+sprite_current+X_OFFSET)
	add hl, de						; Add difference to HL.

	; Do some left/right.
	ld bc, 0xfffe
	in a, (c)

	rra
	rra
	rra
	rra
	jr c, @+no_left

	ld bc, -16
	add hl, bc

	jr @+no_right

@no_left:
	rra
	jr c, @+no_right

	ld bc, 16
	add hl, bc

	;
	; TODO: better camera logic.
	;
	; I suspect something like "if facing left, try to keep sprite on right of screen" and vice versa.
	; The below just gives the sprite a certain boxed area around the centre of the screen, at the
	; edges of which he pushes the camera.
	;

@no_right:
	ld (@+sprite_current+X_OFFSET), hl

	; Check whether player is requesting a jump.
	ld bc, 0x7ffe
	in a, (c)
	rra
	jr c, @+no_jump

	; If player is on the ground, definitely honour and reset the jump count.
	ld a, (@+hero_flags)
	and FLAG_ON_GROUND
	jr z, @+test_jump_count

	ld a, MAX_JUMP_FRAMES
	ld (@+hero_jump_count), a
	jr @+apply_jump

@test_jump_count:
	; Still honour the jump if the button has been held continuously for MAX_JUMP_FRAMES or
	; fewer frames since the player was on the ground.
	ld a, (@+hero_jump_count)
	or a
	jr z, @+no_jump

@apply_jump:
	ld a, (@+hero_jump_count)
	dec a
	ld (@+hero_jump_count), a

	ld hl, (@+sprite_current+Y_OFFSET)
	ld bc, -JUMP_STRENGTH
	add hl, bc
	ld (@+sprite_current+Y_OFFSET), hl
	jr @+did_jump

@no_jump:
	xor a
	ld (@+hero_jump_count), a

@did_jump:
	; Check bounds and force a scroll if necessary.
	ld a, (@+sprite_current+X_OFFSET+1)
	cp 64 + 16
	jr c, @+no_scroll_right

	dec a
	ld (@+sprite_current+X_OFFSET+1), a

	ld a, (@+sprite_previous+X_OFFSET+1)
	dec a
	ld (@+sprite_previous+X_OFFSET+1), a

	call @scroll_right
	jr @+no_scroll_left

@no_scroll_right:
	ld a, (@+sprite_current+X_OFFSET+1)
	cp 64 - 16
	jr nc, @+no_scroll_left

	inc a
	ld (@+sprite_current+X_OFFSET+1), a

	ld a, (@+sprite_previous+X_OFFSET+1)
	inc a
	ld (@+sprite_previous+X_OFFSET+1), a

	call @scroll_left

@no_scroll_left:
	ret

;
; Draws the hero sprite and flags appropriate dirty spots.
;
draw_hero_sprite:
	; Load y, subtract origin, multiply it by 128 and set the top bit.
	ld a, (@+sprite_current+Y_OFFSET+1)
	sub START_Y
	ld h, a
	ld l, 0
	srl h
	set 7, h
	rr l

	; Add x.
	ld a, (@+sprite_current+X_OFFSET+1)
	add l
	ld l, a

	; Call preformed sprite plotter.
	call sprite_1

	;
	; Mark proper dirty bits.
	;


	; Calculate first dirty column, multiplied by three.
	ld a, (@+scroll_offset)
	or a
	jr nz, @+not_zero
	add a, 16
@not_zero:
	rra

	ld e, a
	ld a, (@+sprite_current+X_OFFSET+1)
	add e
	ld c, e

	and 0xf8
	rra
	rra
	ld e, a
	rra
	add e

	; Relocate into dirty flags.
	ld l, a
	ld h, DIRTY_FLAGS >> 8

	;
	; HL = first dirty flags byte for the column the sprite is in.
	;

	ld a, (@+sprite_current+Y_OFFSET+1)
	sub START_Y
	ld b, 64
@search_down:
	cp b
	jr c, @+search_done
	sub b
	inc l
	jr @-search_down
@search_done:

	;
	; HL = first dirty byte flag that sprite actually touches, A = offset within byte.
	;

	and 0xf8		; Divide A by 16 and use bit 3 to decide whether code needs to mark
	rra				; three dirty bits, or only two.
	rra
	rra
	rra
	jr c, @+set_three

	;
	; If here: two bits need to be set, starting from the bit identified in A within
	; the byte pointed to by HL (and possibly again at HL+3, if x&15 is not zero).
	;

	ex de, hl
	ld hl, two_table
	add l
	ld l, a
	ld a, (hl)
	or a
	ex de, hl

	jr z, @+set_adjacent_two	; If the two bits to set overflow this byte, head elsewhere.

@touch_single_byte:
	or (hl)					; Set bits in this byte.
	ld (hl), a

	ld b, a					; Check whether another column needs to be touched.
	ld a, c
	and 0x0f
	ret z

	inc l					; Mark second column
	inc l
	inc l
	ld a, (hl)
	or b
	ld (hl), a
	ret

@set_adjacent_two:
	ld de, 0x2004

@set_adjacent:
	ld a, (hl)				; Set bit in this byte, and in next
	or e
	ld (hl), a
	inc l

	ld a, (hl)
	or d
	ld (hl), a

	ld a, c					; Check whether another column needs to be touched.
	and 0x0f
	ret z

	inc l					; Mark second column
	inc l
	ld a, (hl)
	or e
	ld (hl), a
	inc l
	ld a, (hl)
	or d
	ld (hl), a
	ret

@set_three:

	;
	; If here: three bits need to be set, starting from the bit identified in A within
	; the byte pointed to by HL (and possibly again at HL+3, if x&15 is not zero).
	;

	ex de, hl
	ld hl, three_table
	ld b, a
	add l
	ld l, a
	ld a, (hl)
	or a
	ex de, hl

	jr nz, @-touch_single_byte	; If the three bits to set fit within this byte, jump up.

	ld a, b
	cp 2
	jr z, @+split_2_1

	ld de, 0x3004
	jr @-set_adjacent

@split_2_1:
		
	ld de, 0x200c
	jr @-set_adjacent

	ret

two_table:		db 0x30, 0x18, 0x0c, 0x00
three_table:	db 0x38, 0x1c, 0x00, 0x00

@scroll_offset:	db 0
@map_address: dw map + 12*(column_count)
@diff_address: dw diffs + 3*(column_count - 1)
@next_vmpr: db 0
@scroll_change: db 0
@total_x: dw 0

;
; Adopted coordinate system:
;
;	1 horizontal unit = 2 pixels.
;
;	This both means you can read it as a byte location and
;	it'll give enemies enough range to be able to move off both sides of the screen.
;	Since positions are in fixed point, it also doesn't obstruct true pixel-level placement
;	if I decide to support that.
;
;	Though I've still yet to hammer myself in on an origin. It probably should be that
;	[64, 192] is the visible area.
;
;
;	1 vertical unit = 1 pixels.
;
;	Since the screen is only 192 pixels high there are 64 off-screen pixels without
;	any further adjustment being necessary.
;
;	Right now I'm using position 248 as the bottom of the screen on the basis that
;	jumping over the top of the frame is standard platformer behaviour but dipping
;	below the bottom isn't so common. So that gives 8 rows below and 56 above.
;
@sprite_current:	dw 60 << 8, START_Y << 8
@sprite_previous:	dw 60 << 8, START_Y << 8

@hero_flags:		db 0	; Indicates current player status – which direction they're facing and whether they're on solid ground.
@hero_jump_count:	db 0	; Records how long the jump button has been acknowledged for; pressing for longer gives a higer jump.
@hero_walk_count:	db 0	; Counts number of frames the player has been walking on the ground for, affecting current frame.

FLAG_DIRECTION:		EQU 1
FLAG_ON_GROUND:		EQU 2

MAX_JUMP_FRAMES:	EQU 8
GRAVITY_STRENGTH:	EQU 80
JUMP_STRENGTH:		EQU 300

X_OFFSET:	EQU 0
Y_OFFSET:	EQU 2

START_Y:	EQU 56

; Code to include on the main program page.
INC "generated/sprites.z80s"

; Code that goes elsewhere.
INC "buffer_setup.z80s"
INC "generated/tiles.z80s"
