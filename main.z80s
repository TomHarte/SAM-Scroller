LINE:		EQU 249
STATUS:		EQU 249

LMPR:		EQU 250
HMPR:		EQU 251
VMPR:		EQU 252
BORDER:		EQU 254

EXECPAGE:	EQU 24
SETUPPAGE:	EQU 14

INC "per_buffer_layout.z80s"

	ORG 0
	DUMP EXECPAGE, 0
	AUTOEXEC

	; This program does not use interrupts.
	di

	; Disable display until setup is complete.
	ld a, %10000000
	out (BORDER), a

	; Establish line interrupts at line 191, which will be polled for later.
	ld a, 191
	out (LINE), a

	;
	; The SAM being what it is, execution will actually begin with this code in
	; the upper page.
	;
	; But that's convenient for taking advantage of the setup code — put that
	; initially into the lower page and give it a modified return address.
	;
	ld a, %00100000 + SETUPPAGE
	out (LMPR), a
	ld de, @+fix_page + 0x8000
	jp setup_per_screen_code

@fix_page:
	; Page self to lower page and proceed with execution from there.
	ld a, %00100000 + EXECPAGE
	out (LMPR), a

@redraw_all:
	; Do a full redraw at the current scroll position.
	ld de, @+enter_loop
	jp @+reset_scrolling

@enter_loop:
	; Reenable the display.
	ld a, %00000000
	out (BORDER), a

;
; Initial setup tasks are done now.
;

@draw_scene:

	; Check for keypresses. TODO: actual physics, gameplay, etc.

IF BORDER_PROFILING
	ld a, %00000000
	out (BORDER), a
ENDIF
	; Check and apply keyboard input — cursor left/right only at present.
	ld bc, 0xfffe
	in a, (c)
	rra
	rra
	rra
	rra	; left is now in carry
	jr c, @+test_right

	call @+scroll_left
	jr @+redraw

@test_right:
	rra	; right is now in carry
	jr c, @+redraw

	call @+scroll_right

@redraw:
IF BORDER_PROFILING
	ld a, %00000010
	out (BORDER), a
ENDIF

	; Put next target buffer into the upper page.
	ld a, (@+scroll_offset)
	out (HMPR), a

	; Don't OR anything into the dirty map if there was no scroll.
	ld a, (@+scroll_change)
	or a
	jp z, @+end_logic

	;
	; OR per-page dirty bits with the fixed list to produce a composite diff.
	;
	ld de, DIRTY_FLAGS + FLAGS_SIZE
	ld hl, (@+diff_address)

	; The above assumes a scroll to the right; adjust for a scroll to the left.
	rra
	jr nc, @+or_flags

	ld bc, 3
	add hl, bc

@or_flags:
@or_loop: EQU FOR 51
	dec e
	dec hl

	ld a, (de)
	or (hl)
	ld (de), a
NEXT @or_loop

	; Record no scroll as pending.
	xor a
	ld (@+scroll_change), a

@end_logic:

	;
	; Wait for start of lower border.
	;
@wait:
	in a, (STATUS)
	rra
	jr c, @-wait
	;
	; Display is now beginning the first line of lower border.
	;

IF BORDER_PROFILING
	ld a, %00000001
	out (BORDER), a
ENDIF

	; TODO: do keyboard stuff at end of frame, not top; check for a required scroll
	; and do the flag ORing before updating VMPR, thereby avoiding the bottom-line tear.

	; Switch to displaying whatever is the correct screen.
	ld a, (@+next_vmpr)
	out (VMPR), a

IF BORDER_PROFILING
	ld a, %00000100
	out (BORDER), a
ENDIF

	; Grab map address and set diffs list pointer.
	ld ix, (@+map_address)

	;
	; Segue into tile drawing.
	;
	ld de, @+tiles_drawn
	jp draw_tiles
@tiles_drawn:

	;
	; Set a meaningful SP for code below.
	;
	ld sp, 0

IF BORDER_PROFILING
	ld a, %00000101
	out (BORDER), a
ENDIF

	;
	; Add test sprite.
	;
	call test_sprite

	;
	; Set the page just drawn to as next to display
	;
	ld a, (@+scroll_offset)
	add a, %01100000
	ld (@+next_vmpr), a

;
; Loop for end of frame
;
	jp @-draw_scene


;
; Scrolls the display one position to the left.
;
@scroll_left:
	;
	; Check that total offset is greater than 0; if so then subtract 1
	; and continue. Otherwise return early.
	;
	ld hl, (@+total_x)
	ld a, h
	or l
	ret z

	dec hl
	ld (@+total_x), hl

	; Record that a scroll left happened.
	ld a, 1
	ld (@+scroll_change), a

	;
	; Subtract two from scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	dec a
	dec a
	and 15
	ld (@+scroll_offset), a

	;
	; Update map pointer if the scroll offset just decremented to 0.
	;
	ret nz

	ld hl, (@+map_address)
	ld bc, -12
	add hl, bc
	ld (@+map_address), hl

	ld hl, (@+diff_address)
	ld bc, -3
	add hl, bc
	ld (@+diff_address), hl

	ret

;
; Scrolls the display one position to the right.
;
@scroll_right:
	;
	; Check that total offset is less than the map size; if so then add 1
	; and continue. Otherwise return early.
	;
	ld hl, (@+total_x)
	ld bc, (((diffs - map) / 12) - column_count) * 8
	scf
	ccf
	sbc hl, bc
	ret z

	add hl, bc
	inc hl
	ld (@+total_x), hl

	; Record that a scroll right happened.
	ld a, 2
	ld (@+scroll_change), a

	;
	; Add two to scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	inc a
	inc a
	and 15
	ld (@+scroll_offset), a

	;
	; Do not update map pointer if the scroll offset didn't just increment from 0.
	;
	; Logic here is that offset 1 is the map at offset 0 but moved one position to
	; the left. Therefore the step up from 0 is the point at which the far extent
	; of the map changes.
	;
	ld a, d
	or a
	ret nz

	; Add 12 to map address to move one column along.
	; Correspondingly add 3 to the diff address.
	ld hl, (@+map_address)
	ld bc, 12
	add hl, bc
	ld (@+map_address), hl

	ld hl, (@+diff_address)
	ld bc, 3
	add hl, bc
	ld (@+diff_address), hl

	ret

;
; Performs a full redraw of all video buffers.
;
@reset_scrolling:
	ld (@+return+1), de

	; Seed all buffers.
	ld a, 16
	ld (@+scroll_offset), a
@seed_tiles:
	ld a, (@+scroll_offset)
	or a
	jr z, @+end_seed
	dec a
	dec a
	ld (@+scroll_offset), a
	out (HMPR), a

	ld a, 0x3c
	ld hl, DIRTY_FLAGS
	ld b, FLAGS_SIZE
@flags_loop:
	ld (hl), a
	inc l
	dec b
	jr nz, @-flags_loop

	ld ix, (@+map_address)
	ld de, @-seed_tiles
	jp draw_tiles

@end_seed:
	xor a
	ld (@+scroll_offset), a

@return:
	jp 1234

;
; Experimental: draws a single, rectangular sprite.
;
test_sprite:
	;
	; Apply motion. Just gravity for now.
	;
	ld hl, (@+sprite_current+Y_OFFSET)		; HL = current, BC = previous, and update in-memory copy of previous.
	ld bc, (@+sprite_previous+Y_OFFSET)
	ld (@+sprite_previous+Y_OFFSET), hl

	or a
	sbc hl, bc
	ld d, h
	ld e, l

	sra d
	rr e
	sra d
	rr e
	sra d
	rr e
	sra d
	rr e

	or a
	sbc hl, de

	ex de, hl
	ld hl, (@+sprite_current+Y_OFFSET)
	add hl, de						; Add difference to HL.

	ld bc, 45
	add hl, bc						; Add some gravity.

	;

	; Test for bounds of screen.
	ld a, h
	cp 192 - 24
	jr c, @+test_top

	ld hl, (192 - 24) << 8
	jr @+store_y

@test_top:
	cp 0
	jr nc, @+store_y
	ld hl, 0

@store_y:
	ld (@+sprite_current+Y_OFFSET), hl

	;
	; End move vertically.
	;

	; Load y, multiply it by 128 and set the top bit.
	ld a, (@+sprite_current+Y_OFFSET+1)
	ld h, a
	ld l, 0
	srl h
	set 7, h
	rr l

	; Add x.
	ld a, (@+sprite_current+X_OFFSET+1)
	add l
	ld l, a

	; Call preformed sprite plotter.
	call sprite_1

	;
	; Mark proper dirty bits.
	;


	; Calculate first dirty column, multiplied by three.
	ld a, (@+scroll_offset)
	or a
	jr nz, @+not_zero
	add a, 16
@not_zero:
	rra

	ld e, a
	ld a, (@+sprite_current+X_OFFSET+1)
	add e
	ld c, e

	and 0xf8
	rra
	rra
	ld e, a
	rra
	add e

	; Relocate into dirty flags.
	ld l, a
	ld h, DIRTY_FLAGS >> 8

	;
	; HL = first dirty flags byte for the column the sprite is in.
	;

	ld a, (@+sprite_current+Y_OFFSET+1)
	ld b, 64
@search_down:
	cp b
	jr c, @+search_done
	sub b
	inc l
	jr @-search_down
@search_done:

	;
	; HL = first dirty byte flag that sprite actually touches, A = offset within byte.
	;

	and 0xf8		; Divide A by 16 and use bit 3 to decide whether code needs to mark
	rra				; three dirty bits, or only two.
	rra
	rra
	rra
	jr c, @+set_three

	;
	; If here: two bits need to be set, starting from the bit identified in A within
	; the byte pointed to by HL (and possibly again at HL+3, if x&15 is not zero).
	;

	ex de, hl
	ld hl, two_table
	add l
	ld l, a
	ld a, (hl)
	or a
	ex de, hl

	jr z, @+set_adjacent_two	; If the two bits to set overflow this byte, head elsewhere.

@touch_single_byte:
	or (hl)					; Set bits in this byte.
	ld (hl), a

	ld b, a					; Check whether another column needs to be touched.
	ld a, c
	and 0x0f
	ret z

	inc l					; Mark second column
	inc l
	inc l
	ld a, (hl)
	or b
	ld (hl), a
	ret

@set_adjacent_two:
	ld de, 0x2004

@set_adjacent:
	ld a, (hl)				; Set bit in this byte, and in next
	or e
	ld (hl), a
	inc l

	ld a, (hl)
	or d
	ld (hl), a

	ld a, c					; Check whether another column needs to be touched.
	and 0x0f
	ret z

	inc l					; Mark second column
	inc l
	ld a, (hl)
	or e
	ld (hl), a
	inc l
	ld a, (hl)
	or d
	ld (hl), a
	ret

@set_three:

	;
	; If here: three bits need to be set, starting from the bit identified in A within
	; the byte pointed to by HL (and possibly again at HL+3, if x&15 is not zero).
	;

	ex de, hl
	ld hl, three_table
	ld b, a
	add l
	ld l, a
	ld a, (hl)
	or a
	ex de, hl

	jr nz, @-touch_single_byte	; If the three bits to set fit within this byte, jump up.

	ld a, b
	cp 2
	jr z, @+split_2_1

	ld de, 0x3004
	jr @-set_adjacent

@split_2_1:
		
	ld de, 0x200c
	jr @-set_adjacent

	ret

two_table:		db 0x30, 0x18, 0x0c, 0x00
three_table:	db 0x38, 0x1c, 0x00, 0x00

@scroll_offset:	db 0
@map_address: dw map + 12*(column_count)
@diff_address: dw diffs + 3*(column_count - 1)
@next_vmpr: db 0
@scroll_change: db 0
@total_x: dw 0

@sprite_current:	dw 0, 0
@sprite_previous:	dw 0, 0
X_OFFSET:	EQU 0
Y_OFFSET:	EQU 2

; Code to include on the main program page.
INC "generated/sprites.z80s"

; Code that goes elsewhere.
INC "buffer_setup.z80s"
INC "generated/tiles.z80s"
