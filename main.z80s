LINE:		EQU 249
STATUS:		EQU 249

LMPR:		EQU 250
HMPR:		EQU 251
VMPR:		EQU 252
BORDER:		EQU 254

EXECPAGE:	EQU 24

INC "per_buffer_layout.z80s"

	ORG 0
	DUMP EXECPAGE, 0
INC "generated/palette.z80s"
	AUTOEXEC

	di

	; Establish line interrupts at line 191, which will be polled for later.
	ld a, 191
	out (LINE), a

	; Page self to lower page and proceed with execution from there.
	ld a, %00100000 + EXECPAGE
	out (LMPR), a
	jp @+relocate

@relocate:
	; Disable display until the following is complete.
	ld a, %10000000
	out (BORDER), a

	; Establish palette.
	ld bc, 0x10f8
	ld hl, palette+15
	otdr

	; Setup all screens.
	ld e, 16
	exx
@setup_screen:
	exx
	ld a, e
	dec a
	dec a
	out (HMPR), a
	ld e, a
	exx
	jp m, @+break_setup_screen

	ld sp, 0 - 8*1024
	ld bc, 24*1024 / 4
	ld hl, 0
@blank_loop:
	push hl
	push hl
	dec bc
	ld a, b
	or c
	jr nz, @-blank_loop

	ld a, 0x1e
	ld hl, DIRTY_FLAGS
	ld b, FLAGS_SIZE
@flags_loop:
	ld (hl), a
	inc l
	dec b
	jr nz, @-flags_loop

	; Copy down tile-drawing code.
	exx
	ld a, e
	ld hl, BUFFER_CODE_ORIGINAL
	ld de, BUFFER_CODE
	ld bc, BUFFER_CODE_DONE-BUFFER_CODE
	ldir
	ld e, a
	exx

	; Set start addresses.
	ld de, 128*192 + 32768		; Start of first column

	; If a is odd byte size, start one earlier.
	srl a
	srl a
	jr nc, @+no_dec
	dec de
@no_dec:

	ld ix, columns_start
	ld a, 0
@address_loop:
	ld (ix + buffer_start_offset), e
	ld (ix + buffer_start_offset + 1), d
	ld bc, column_length
	add ix, bc						; Update IX to point to the next buffer address.

	or a
	jr nz, @+sub8
	exx
	ex af, af'
	ld a, e
	exx

	or a
	jr z, @+sub8

	ex de, hl
	srl a						; Subtract a distance for the target page.
	and 0xfe
	ld c, a
	ld b, 0
	sbc hl, bc					; C is clear from the SRL above.

	ex af, af'

	jr @+adjusted
@sub8:
	ex de, hl
	ld bc, -8
	add hl, bc
@adjusted:
	ex de, hl

	inc a
	cp column_count
	jr nz, @-address_loop			; Loop until done.

	jp @-setup_screen

@break_setup_screen:

	; First page: just do 16 columns by adding an extra JR.
	ld a, 0
	out (HMPR), a
	ld ix, columns_end - column_length
	ld (ix + 0), 0x18
	ld (ix + 1), column_length - 2

	; Second page: use left_1 and right_7.
	ld a, 2
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_1_page
	ld (ix + tile_table_offset1), tiles_left_1 >> 8
	ld (ix + tile_table_offset2), tiles_left_1 >> 8
	ld (ix + tile_table_offset3), tiles_left_1 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_7_page
	ld (ix + tile_table_offset1), tiles_right_7 >> 8
	ld (ix + tile_table_offset2), tiles_right_7 >> 8
	ld (ix + tile_table_offset3), tiles_right_7 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	; Third page: use left_2 and right_6.
	ld a, 4
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_2_page
	ld (ix + tile_table_offset1), tiles_left_2 >> 8
	ld (ix + tile_table_offset2), tiles_left_2 >> 8
	ld (ix + tile_table_offset3), tiles_left_2 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_6_page
	ld (ix + tile_table_offset1), tiles_right_6 >> 8
	ld (ix + tile_table_offset2), tiles_right_6 >> 8
	ld (ix + tile_table_offset3), tiles_right_6 >> 8

	; Fourth page: use left_3 and right_5.
	ld a, 6
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_3_page
	ld (ix + tile_table_offset1), tiles_left_3 >> 8
	ld (ix + tile_table_offset2), tiles_left_3 >> 8
	ld (ix + tile_table_offset3), tiles_left_3 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_5_page
	ld (ix + tile_table_offset1), tiles_right_5 >> 8
	ld (ix + tile_table_offset2), tiles_right_5 >> 8
	ld (ix + tile_table_offset3), tiles_right_5 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	; Fifth page: use left_4 and right_4.
	ld a, 8
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_4_page
	ld (ix + tile_table_offset1), tiles_left_4 >> 8
	ld (ix + tile_table_offset2), tiles_left_4 >> 8
	ld (ix + tile_table_offset3), tiles_left_4 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_4_page
	ld (ix + tile_table_offset1), tiles_right_4 >> 8
	ld (ix + tile_table_offset2), tiles_right_4 >> 8
	ld (ix + tile_table_offset3), tiles_right_4 >> 8

	; Sixth page: use left_5 and right_3.
	ld a, 10
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_5_page
	ld (ix + tile_table_offset1), tiles_left_5 >> 8
	ld (ix + tile_table_offset2), tiles_left_5 >> 8
	ld (ix + tile_table_offset3), tiles_left_5 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_3_page
	ld (ix + tile_table_offset1), tiles_right_3 >> 8
	ld (ix + tile_table_offset2), tiles_right_3 >> 8
	ld (ix + tile_table_offset3), tiles_right_3 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	; Seventh page: use left_6 and right_2.
	ld a, 12
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_6_page
	ld (ix + tile_table_offset1), tiles_left_6 >> 8
	ld (ix + tile_table_offset2), tiles_left_6 >> 8
	ld (ix + tile_table_offset3), tiles_left_6 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_2_page
	ld (ix + tile_table_offset1), tiles_right_2 >> 8
	ld (ix + tile_table_offset2), tiles_right_2 >> 8
	ld (ix + tile_table_offset3), tiles_right_2 >> 8

	; Eighth page: use left_7 and right_1.
	ld a, 14
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_7_page
	ld (ix + tile_table_offset1), tiles_left_7 >> 8
	ld (ix + tile_table_offset2), tiles_left_7 >> 8
	ld (ix + tile_table_offset3), tiles_left_7 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_1_page
	ld (ix + tile_table_offset1), tiles_right_1 >> 8
	ld (ix + tile_table_offset2), tiles_right_1 >> 8
	ld (ix + tile_table_offset3), tiles_right_1 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	; Seed all buffers.
	ld a, 16
	ld (@+scroll_offset), a
@seed_tiles:
	ld a, (@+scroll_offset)
	or a
	jr z, @+end_seed
	dec a
	dec a
	ld (@+scroll_offset), a
	out (HMPR), a

	ld ix, (@+map_address)
	ld iy, DIRTY_FLAGS + FLAGS_SIZE
	ld de, @+tiles_drawn
	jp draw_tiles
@tiles_drawn:

	ld a, 0
	ld hl, DIRTY_FLAGS
	ld b, FLAGS_SIZE
@flags_loop:
	ld (hl), a
	inc l
	dec b
	jr nz, @-flags_loop

	jr @-seed_tiles

@end_seed:
	ld a, 0
	ld (@+scroll_offset), a


	; Reenable the display.
	ld a, %00000000
	out (BORDER), a

;
; Initial setup tasks are done now.
;

@draw_scene:

	;
	; Wait for start of lower border.
	;
@wait:
	in a, (STATUS)
	rra
	jr c, @-wait
	;
	; Display is now beginning the first line of lower border.
	;

	; Switch to displaying whatever is the correct screen.
	ld a, (@+next_vmpr)
	out (VMPR), a

	; Record no scroll as having occurred.
	xor a
	ld (@+scroll_change), a

	; Check and apply keyboard input â€” cursor left/right only at present.
	ld bc, 0xfffe
	in a, (c)
	rra
	rra
	rra

	; Lazily set b0 = 1 if a scroll to the left happened;
	; b1 = 1 if a scroll to the right happened (and there wasn't a scroll to the left).
	and 3
	xor 3
	ld (@+scroll_change), a

	rra	; left is now in carry
	jr nc, @+test_right

	ld de, @+redraw
	jp @+scroll_left

@test_right:
	rra	; right is now in carry
	jr nc, @+redraw

	ld de, @+redraw
	jp @+scroll_right

@redraw:
	; Put next page into the upper page.
	ld a, (@+scroll_offset)
	out (HMPR), a

	; Don't OR anything in if there was no scroll.
	ld a, (@+scroll_change)
	or a
	jr z, @+begin_map

@or_diff_map:

	;
	; OR per-page dirty bits with the fixed list to produce a composite diff.
	;
	; TODO: don't OR in dirty bits if there was no scrolling, OR them in but
	; off by one if scrolling went leftward.
	ld de, DIRTY_FLAGS + FLAGS_SIZE
	ld hl, (@+diff_address)

	; The above assumes a scroll to the right; adjust for a scroll to the left.
	rra
	jr nc, @+or_flags

	ld bc, -3
	add hl, bc

@or_flags:
	ld c, FLAGS_SIZE
@flag_loop:
	dec de
	dec hl

	ld a, (de)
	or (hl)
	ld (de), a

	dec c
	jr nz, @-flag_loop

@begin_map:
	; Grab map address and set diffs list pointer.
	ld ix, (@+map_address)
	ld iy, DIRTY_FLAGS + FLAGS_SIZE

	;
	; Segue into tile drawing.
	;
	ld de, @+tiles_drawn
	jp draw_tiles
@tiles_drawn:

	;
	; Set the page just drawn to as next to display
	;
	ld a, (@+scroll_offset)
	add a, %01100000
	ld (@+next_vmpr), a

;
; Loop for end of frame
;
	jr @-draw_scene


@scroll_left:
	ld (@+return+1), de

	;
	; Subtract two from scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	dec a
	dec a
	and 15
	ld (@+scroll_offset), a

	;
	; Update map pointer if the scroll offset just decremented to 0.
	;
	jp nz, @+return

	ld hl, (@+map_address)
	ld bc, -12
	add hl, bc

	ld hl, (@+diff_address)
	ld bc, -3
	add hl, bc
	ld (@+diff_address), hl

@return:
	jp 1234

@scroll_right:
	ld (@+return+1), de

	;
	; Add two to scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	inc a
	inc a
	and 15
	ld (@+scroll_offset), a

	;
	; Do not update map pointer if the scroll offset didn't just increment from 0.
	;
	; Logic here is that offset 1 is the map at offset 0 but moved one position to
	; the left. Therefore the step up from 0 is the point at which the far extent
	; of the map changes.
	;
	ld a, d
	or a
	jp nz, @+return

	; Add 12 to map address to move one column along.
	; Correspondingly add 3 to the diff address.
	ld hl, (@+map_address)
	ld bc, 12
	add hl, bc

	; Stop scrolling if at end of bounds.
	scf
	ccf
	ld bc, diffs - 12*column_count
	sbc hl, bc
	jr nz, @+keep_scrolling

	ld a, 0
	ld (@+scroll_offset), a
	jr @+return

@keep_scrolling:
	add hl, bc

	ld (@+map_address), hl

	ld hl, (@+diff_address)
	ld bc, 3
	add hl, bc
	ld (@+diff_address), hl

@return:
	jp 1234


@scroll_offset:	db 0
@map_address: dw map + 12*(column_count + 1)
@diff_address: dw diffs + 3*column_count
@next_vmpr: db 0
@scroll_change: db 0

;
; The section from here to BUFFER_CODE_DONE is copied into place on
; each video page individually, fixed up slightly for the appropriate
; tile functions.
;
BUFFER_CODE_ORIGINAL:
include "per_buffer_code.z80s"
BUFFER_CODE_DONE:

;
; End relocated section.
;

INC "generated/tiles.z80s"
