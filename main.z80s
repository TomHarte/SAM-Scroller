LINE:		EQU 249
STATUS:		EQU 249

LMPR:		EQU 250
HMPR:		EQU 251
VMPR:		EQU 252
BORDER:		EQU 254

EXECPAGE:	EQU 24
SETUPPAGE:	EQU 14

INC "per_buffer_layout.z80s"

	ORG 0
	DUMP EXECPAGE, 0
	AUTOEXEC

	; This program does not use interrupts
	di

	; Disable display until the following is complete.
	ld a, %10000000
	out (BORDER), a

	; Establish line interrupts at line 191, which will be polled for later.
	ld a, 191
	out (LINE), a

	;
	; The SAM being what it is, execution will actually begin with this code in
	; the upper page.
	;
	; But that's convenient for taking advantage of the setup code.
	;
	ld a, %00100000 + SETUPPAGE
	out (LMPR), a

	; Copy the per-screen code segments far and wide.
	ld de, @+redraw_all + 0x8000
	jp @+setup_per_screen_code
@redraw_all:

	; Page self to lower page and proceed with execution from there.
	ld a, %00100000 + EXECPAGE
	out (LMPR), a
	jp @+relocate

@relocate:

	; Seed all buffers.
	ld a, 16
	ld (@+scroll_offset), a
@seed_tiles:
	ld a, (@+scroll_offset)
	or a
	jr z, @+end_seed
	dec a
	dec a
	ld (@+scroll_offset), a
	out (HMPR), a

	ld a, 0x1e
	ld hl, DIRTY_FLAGS
	ld b, FLAGS_SIZE
@flags_loop:
	ld (hl), a
	inc l
	dec b
	jr nz, @-flags_loop

	ld ix, (@+map_address)
	ld iy, DIRTY_FLAGS + FLAGS_SIZE
	ld de, @-seed_tiles
	jp draw_tiles

@end_seed:
	ld a, 0
	ld (@+scroll_offset), a


	; Reenable the display.
	ld a, %00000000
	out (BORDER), a

;
; Initial setup tasks are done now.
;

@draw_scene:

	;
	; Wait for start of lower border.
	;
@wait:
	in a, (STATUS)
	rra
	jr c, @-wait
	;
	; Display is now beginning the first line of lower border.
	;

	; Switch to displaying whatever is the correct screen.
	ld a, (@+next_vmpr)
	out (VMPR), a

	; Record no scroll as having occurred.
	xor a
	ld (@+scroll_change), a

	; Check and apply keyboard input â€” cursor left/right only at present.
	ld bc, 0xfffe
	in a, (c)
	rra
	rra
	rra

	; Lazily set b0 = 1 if a scroll to the left happened;
	; b1 = 1 if a scroll to the right happened (and there wasn't a scroll to the left).
	and 3
	xor 3
	ld (@+scroll_change), a

	rra	; left is now in carry
	jr nc, @+test_right

	ld de, @+redraw
	jp @+scroll_left

@test_right:
	rra	; right is now in carry
	jr nc, @+redraw

	ld de, @+redraw
	jp @+scroll_right

@redraw:
	; Put next page into the upper page.
	ld a, (@+scroll_offset)
	out (HMPR), a

	; Don't OR anything in if there was no scroll.
	ld a, (@+scroll_change)
	or a
	jr z, @+begin_map

@or_diff_map:

	;
	; OR per-page dirty bits with the fixed list to produce a composite diff.
	;
	ld de, DIRTY_FLAGS + FLAGS_SIZE
	ld hl, (@+diff_address)

	; The above assumes a scroll to the right; adjust for a scroll to the left.
	rra
	jr nc, @+or_flags

	ld bc, 3
	add hl, bc

@or_flags:
	ld c, FLAGS_SIZE
@flag_loop:
	dec de
	dec hl

	ld a, (de)
	or (hl)
	ld (de), a

	dec c
	jr nz, @-flag_loop

@begin_map:
	; Grab map address and set diffs list pointer.
	ld ix, (@+map_address)
	ld iy, DIRTY_FLAGS + FLAGS_SIZE

	;
	; Segue into tile drawing.
	;
	ld de, @+tiles_drawn
	jp draw_tiles
@tiles_drawn:

	;
	; Set the page just drawn to as next to display
	;
	ld a, (@+scroll_offset)
	add a, %01100000
	ld (@+next_vmpr), a

;
; Loop for end of frame
;
	jr @-draw_scene


@scroll_left:
	ld (@+return+1), de

	;
	; Check that total offset is greater than 0; if so then subtract 1
	; and continue. Otherwise return early.
	;
	ld hl, (@+total_x)
	ld a, h
	or l
	jr z, @+return
	dec hl
	ld (@+total_x), hl

	;
	; Subtract two from scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	dec a
	dec a
	and 15
	ld (@+scroll_offset), a

	;
	; Update map pointer if the scroll offset just decremented to 0.
	;
	jp nz, @+return

	ld hl, (@+map_address)
	ld bc, -12
	add hl, bc
	ld (@+map_address), hl

	ld hl, (@+diff_address)
	ld bc, -3
	add hl, bc
	ld (@+diff_address), hl

@return:
	jp 1234

@scroll_right:
	ld (@+return+1), de

	;
	; Check that total offset is less than the map size; if so then add 1
	; and continue. Otherwise return early.
	;
	ld hl, (@+total_x)
	ld bc, (((diffs - map) / 12) - column_count) * 8
	scf
	ccf
	sbc hl, bc
	jr z, @+return
	add hl, bc
	inc hl
	ld (@+total_x), hl

	;
	; Add two to scroll offset.
	;
	ld a, (@+scroll_offset)
	ld d, a
	inc a
	inc a
	and 15
	ld (@+scroll_offset), a

	;
	; Do not update map pointer if the scroll offset didn't just increment from 0.
	;
	; Logic here is that offset 1 is the map at offset 0 but moved one position to
	; the left. Therefore the step up from 0 is the point at which the far extent
	; of the map changes.
	;
	ld a, d
	or a
	jp nz, @+return

	; Add 12 to map address to move one column along.
	; Correspondingly add 3 to the diff address.
	ld hl, (@+map_address)
	ld bc, 12
	add hl, bc
	ld (@+map_address), hl

	ld hl, (@+diff_address)
	ld bc, 3
	add hl, bc
	ld (@+diff_address), hl

@return:
	jp 1234

@scroll_offset:	db 0
@map_address: dw map + 12*(column_count)
@diff_address: dw diffs + 3*(column_count - 1)
@next_vmpr: db 0
@scroll_change: db 0
@total_x: dw 0


;
; This is purely one-time startup stuff; relocate it into one of the initial video buffers
; so that it naturally doesn't have an ongoing footprint.
;

DUMP SETUPPAGE, 0
ORG 0

@setup_per_screen_code:
	ld (@+return+1), de

	; Establish palette.
	ld bc, 0x10f8
	ld hl, palette+15
	otdr

	; Setup all screens.
	;
	; (1) copy tile-drawing code, unmodified.
	;
	ld a, 0
@copy_buffer_code:
	out (HMPR), a

	; Copy down tile-drawing code.
	ld hl, BUFFER_CODE_ORIGINAL
	ld de, BUFFER_CODE
	ld bc, BUFFER_CODE_DONE-BUFFER_CODE
	ldir

	; Set first two start addresses.
	ld ix, columns_start
	ld hl, 128*192 + 32768		; Start of rightmost column.

	; If a is odd byte size, start one earlier, per the different rules for even-sized
	; and odd-sized tile output functions.
	ld c, a
	srl c
	srl c
	jr nc, @+no_dec
	dec hl

@no_dec:
	; Store first address.
	ld (ix + buffer_start_offset), l
	ld (ix + buffer_start_offset + 1), h

	; Next will be at [screen end] - (a >> 1) {- 8 for page 0}.
	ld hl, 128*192 + 32768

	or a
	jr z, @+sub8
	ld c, a
	ld b, 0
	srl c
	sbc hl, bc
	jr @+store

@sub8:
	ld bc, -8
	add hl, bc

	; Store second address
@store:
	ld (ix + buffer_start_offset + column_length), l
	ld (ix + buffer_start_offset + column_length + 1), h

	;
	; Proceed from the second column address, decreasing by 8 across the
	; rest of the set.
	;
	ld ix, columns_start + column_length
	ld e, column_count - 2
@address_loop:
	ld bc, column_length
	add ix, bc						; Update IX to point to the next buffer address.

	ld bc, -8
	add hl, bc
	ld (ix + buffer_start_offset), l
	ld (ix + buffer_start_offset + 1), h

	dec e
	jr nz, @-address_loop			; Loop until done.

	; Continue to next page.
	add 2
	cp 16
	jr nz, @-copy_buffer_code

	;
	; Apply per-page adjustments to locate proper tile pages.
	;

	; First page: just do 16 columns by adding an extra JR.
	ld a, 0
	out (HMPR), a
	ld ix, columns_end - column_length
	ld (ix + 0), 0x18
	ld (ix + 1), column_length - 2

	; Second page: use left_1 and right_7.
	ld a, 2
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_1_page
	ld (ix + tile_table_offset1), tiles_left_1 >> 8
	ld (ix + tile_table_offset2), tiles_left_1 >> 8
	ld (ix + tile_table_offset3), tiles_left_1 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_7_page
	ld (ix + tile_table_offset1), tiles_right_7 >> 8
	ld (ix + tile_table_offset2), tiles_right_7 >> 8
	ld (ix + tile_table_offset3), tiles_right_7 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	; Third page: use left_2 and right_6.
	ld a, 4
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_2_page
	ld (ix + tile_table_offset1), tiles_left_2 >> 8
	ld (ix + tile_table_offset2), tiles_left_2 >> 8
	ld (ix + tile_table_offset3), tiles_left_2 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_6_page
	ld (ix + tile_table_offset1), tiles_right_6 >> 8
	ld (ix + tile_table_offset2), tiles_right_6 >> 8
	ld (ix + tile_table_offset3), tiles_right_6 >> 8

	; Fourth page: use left_3 and right_5.
	ld a, 6
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_3_page
	ld (ix + tile_table_offset1), tiles_left_3 >> 8
	ld (ix + tile_table_offset2), tiles_left_3 >> 8
	ld (ix + tile_table_offset3), tiles_left_3 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_5_page
	ld (ix + tile_table_offset1), tiles_right_5 >> 8
	ld (ix + tile_table_offset2), tiles_right_5 >> 8
	ld (ix + tile_table_offset3), tiles_right_5 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	; Fifth page: use left_4 and right_4.
	ld a, 8
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_4_page
	ld (ix + tile_table_offset1), tiles_left_4 >> 8
	ld (ix + tile_table_offset2), tiles_left_4 >> 8
	ld (ix + tile_table_offset3), tiles_left_4 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_4_page
	ld (ix + tile_table_offset1), tiles_right_4 >> 8
	ld (ix + tile_table_offset2), tiles_right_4 >> 8
	ld (ix + tile_table_offset3), tiles_right_4 >> 8

	; Sixth page: use left_5 and right_3.
	ld a, 10
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_5_page
	ld (ix + tile_table_offset1), tiles_left_5 >> 8
	ld (ix + tile_table_offset2), tiles_left_5 >> 8
	ld (ix + tile_table_offset3), tiles_left_5 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_3_page
	ld (ix + tile_table_offset1), tiles_right_3 >> 8
	ld (ix + tile_table_offset2), tiles_right_3 >> 8
	ld (ix + tile_table_offset3), tiles_right_3 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	; Seventh page: use left_6 and right_2.
	ld a, 12
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_6_page
	ld (ix + tile_table_offset1), tiles_left_6 >> 8
	ld (ix + tile_table_offset2), tiles_left_6 >> 8
	ld (ix + tile_table_offset3), tiles_left_6 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_2_page
	ld (ix + tile_table_offset1), tiles_right_2 >> 8
	ld (ix + tile_table_offset2), tiles_right_2 >> 8
	ld (ix + tile_table_offset3), tiles_right_2 >> 8

	; Eighth page: use left_7 and right_1.
	ld a, 14
	out (HMPR), a
	ld ix, columns_start
	ld (ix + tile_page_offset), tiles_left_7_page
	ld (ix + tile_table_offset1), tiles_left_7 >> 8
	ld (ix + tile_table_offset2), tiles_left_7 >> 8
	ld (ix + tile_table_offset3), tiles_left_7 >> 8

	ld ix, columns_end - column_length
	ld (ix + tile_page_offset), tiles_right_1_page
	ld (ix + tile_table_offset1), tiles_right_1 >> 8
	ld (ix + tile_table_offset2), tiles_right_1 >> 8
	ld (ix + tile_table_offset3), tiles_right_1 >> 8

	ld ix, columns_start + (column_count - 1) * column_length
	dec (ix + buffer_start_offset)

	ld a, EXECPAGE
	out (HMPR), a
@return:
	jp 1234

INC "generated/palette.z80s"

;
; The section from here to BUFFER_CODE_DONE is copied into place on
; each video page individually, fixed up slightly for the appropriate
; tile functions.
;
BUFFER_CODE_ORIGINAL:
include "per_buffer_code.z80s"
BUFFER_CODE_DONE:
;
; End relocated section.
;

INC "generated/tiles.z80s"
