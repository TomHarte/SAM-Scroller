LINE:		EQU 249
STATUS:		EQU 249

LMPR:		EQU 250
HMPR:		EQU 251
VMPR:		EQU 252
BORDER:		EQU 254

EXECPAGE:	EQU 24
SETUPPAGE:	EQU 14


;
; Constants affecting animation.
;
WALK_FRAME_DURATION:		EQU 10

;
; Constants defining the coordinate system.
;
START_X:	EQU 64		; Offset of the left of the display in internal coordinates. Making this a multiple of 16 simplifies map collision detection.
START_Y:	EQU 48		; Offset of the top of the display in internal coordinates. Making this a multiple of 16 simplifies map collision detection.
Y_CEILING:	EQU 8		; Position at which player will bump his head in internal coordinate; needs to be more than 0 to avoid tunnelling.

	ORG 0
	DUMP EXECPAGE, 0
	AUTOEXEC

	; This program does not use interrupts.
	di

	; Disable display until setup is complete.
	ld a, %10000000
	out (BORDER), a

	; Establish line interrupts at line 191, which will be polled for later.
	ld a, 191
	out (LINE), a

	;
	; The SAM being what it is, execution will actually begin with this code in
	; the upper page.
	;
	; But that's convenient for taking advantage of the setup code â€” put that
	; initially into the lower page and give it a modified return address.
	;
	ld a, %00100000 + SETUPPAGE
	out (LMPR), a
	ld de, @+fix_page + 0x8000
	jp setup_per_screen_code

@fix_page:
	; Page self to lower page and proceed with execution from there.
	ld a, %00100000 + EXECPAGE
	out (LMPR), a

	; Do a full redraw at the current scroll position.
	ld de, @+enter_loop
	jp reset_scrolling
@enter_loop:

	; Reenable the display.
	ld a, %00000000
	out (BORDER), a

;
; Initial setup tasks are done now.
;
; With no title screen, etc, yet implemented, just jump straight to the in-game loop.
;
	jp game_loop



NUM_OBJECTS:		EQU 4		; Currently: allow at max four objects. Which is probably optimistic.

@no_function:		ret
objects:
@object_content: 	EQU FOR NUM_OBJECTS
	dw 0, 0						; Object position.
	dw 0, 0						; Previous position.
	db 0						; Image. Set to 0 to disable object.
	jp @-no_function			; Function pointer for 'update object'
	dw 0						; Source ID; used to avoid double spawning.
	ds 4						; Spare storage, usable by update object function for state. Sized arbitrarily.
NEXT @object_content
@end_objects:

; Various offsets within an object.
Object.Position:			EQU 0
Object.PreviousPosition:	EQU 4
Object.Image:				EQU 8
Object.Jump:				EQU 9
Object.SourceID:			EQU 12
Object.OwnedState:			EQU 14
OBJECT_SIZE:				EQU (@-end_objects - objects) / NUM_OBJECTS

OBJECT_CULL_THRESHOLD:		EQU 32		; The number of byte columns an object must be beyond the edge of the screen
										; to be culled from the active list.

update_game_logic:
	;
	; Call update function on each and every active object.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	; [Indirectly] call into the update function.
	ld ix, @object
	call @object + Object.Jump

	;
	; Check whether position has crossed a threshold into being so far
	; off-screen that it is time to be culled.
	;

	ld a, (@object + Object.Position + Position.x + 1)
	cp START_X - 8 - OBJECT_CULL_THRESHOLD
	jp c, @+cull_object

	cp START_X + 128 + OBJECT_CULL_THRESHOLD
	jp c, @+next_object

@cull_object:
	xor a
	ld (@object + Object.Image), a

@next_object:
NEXT @test_object

	jp update_player_logic


did_scroll_left1:
	;
	; Update positions of all active objects.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	;
	; Increment position.
	;
	ld a, (@object + Object.Position + Position.x + 1)
	inc a
	ld (@object + Object.Position + Position.x + 1), a

	ld a, (@object + Object.PreviousPosition + Position.x + 1)
	inc a
	ld (@object + Object.PreviousPosition + Position.x + 1), a

@no_object:
NEXT @test_object

	ret


did_scroll_right1:
	;
	; Update positions of all active objects.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	;
	; Decrement position.
	;
	ld a, (@object + Object.Position + Position.x + 1)
	dec a
	ld (@object + Object.Position + Position.x + 1), a

	ld a, (@object + Object.PreviousPosition + Position.x + 1)
	dec a
	ld (@object + Object.PreviousPosition + Position.x + 1), a

@next_object:
NEXT @test_object
	ret


;
; Finds an object slot for the object with source ID as per HL, if no slot is currently
; allocated to that object and if one is available.
;
; Returns carry clear if no slot is available. Carry set otherwise.
; If carry is set, IX points to the available slot.
;
@find_object_slot:
@test_presence: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_presence * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	ld a, (@object + Object.SourceID)
	cp h
	jp nz, @+next_object

	ld a, (@object + Object.SourceID + 1)
	cp l
	ret z

@next_object:
NEXT @test_presence

@find_slot: EQU FOR NUM_OBJECTS
	@object: EQU objects + @find_slot * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp nz, @+next_object

	; Available slot found; return.
	ld ix, @object
	scf
	ret

@next_object:
NEXT @find_slot

	; No free slot found.
	or a
	ret

did_scroll_left8:
	; TODO: check event list potentially to spawn new objects.

	ret


did_scroll_right8:
	; TODO: check event list potentially to spawn new objects.

	; HACK: check for appearance on the right of column 50 and seed an object if it appears.
	ld a, (scroll_column)
	add 17
	cp 50
	ret nz

	; Find an empty object slot.
	ld hl, 0
	call @-find_object_slot
	ret nc

	; Install at IX.
	ld (ix + Object.Position + Position.x + 0), 0
	ld (ix + Object.Position + Position.x + 1), START_X + 17 * 8		; i.e. in the allotted column.

	ld (ix + Object.Position + Position.y + 0), 0
	ld (ix + Object.Position + Position.y + 1), START_Y + 120			; Where I happen to know the ground is.

	jp @+seed_frog


draw_objects:
	;
	; Draw all active objects.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	; Draw the object.
	ld h, a
	ld a, (@object + Object.Position + Position.y + 1)
	sub START_Y
	ld d, a
	ld a, (@object + Object.Position + Position.x + 1)
	ld e, a

	call draw_clippable		; TODO: if this could return a flag indicating whether the object was drawn, some work
							; could be saved below?

	; Also TODO: can this be moved to the update function? Should be safe
	; as that occurs prior to any potential scrolling, but check.

	ld a, (@object + Object.Position + Position.x + 1)
	ld b, a
	ld a, (@object + Object.Position + Position.y + 1)
	ld c, a
	call clip_mark16x24

@next_object:
NEXT @test_object

	;
	; Draw player.
	;
	jp draw_player_sprite


@seed_frog:
	ld (ix + Object.Image), clippable_0 >> 8

	ld (ix + Object.Jump + 1), @+update_frog & 0xff
	ld (ix + Object.Jump + 2), @+update_frog >> 8

	ld (ix + Object.OwnedState), 0
	scf
	ret

@update_frog:
	; Just switch sprite based on a timer. No great logic here.
	ld a, (ix + Object.OwnedState)
	inc a
	ld (ix + Object.OwnedState), a

	and 16
	jp nz, @+first_frame

	ld (ix + Object.Image), clippable_0 >> 8
	ret

@first_frame:
	ld (ix + Object.Image), clippable_1 >> 8

	ld a, (ix + Object.OwnedState)
	and 15

	ld hl, frog_heights
	ld c, a
	ld b, 0
	add hl, bc
	ld a, (hl)
	add a, (ix + Object.Position + Position.y + 1)
	ld (ix + Object.Position + Position.y + 1), a
	ret

frog_heights:
@frog_table: EQU FOR 16
	db -10*(sin(pi * @frog_table / 15.0) - sin(pi * ((@frog_table - 1) & 15) / 15.0))
NEXT @frog_table


;
; Defines the layout of an 'event', which is tied to the appearance of a screen column
; and usually but not necessarily involves the addition of an object.
;
Event.Column:			EQU 0
Event.InitialY:			EQU 2
Event.SetupFunction:	EQU 3
EVENT_SIZE:				EQU Event.SetupFunction + 2

events:
	; A non-event in column 0; this gives the left list somewhere to anchor to.
	dw 0
	db 0
	dw @-no_function

	; A frog in column 50.
	dw 50
	db START_Y + 120
	dw @-seed_frog

	; A terminating event, which is so far out of bounds as never to trigger.
	dw 0xffff

events_to_left:		dw events					; Points to the next event that should occur on the left.
events_to_right:	dw events + EVENT_SIZE		; Points to the next event that should occur on the right.

; Code to include on the main program page.
INC "game_loop.z80s"
INC "generated/sprites.z80s"
INC "mark_dirty.z80s"
INC "player/display.z80s"
INC "player/logic.z80s"
INC "scrolling.z80s"

; Code that goes elsewhere.
INC "video_buffers/buffer_setup.z80s"
INC "generated/tiles.z80s"
