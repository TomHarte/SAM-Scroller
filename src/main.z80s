LINE:		EQU 249
STATUS:		EQU 249

LMPR:		EQU 250
HMPR:		EQU 251
VMPR:		EQU 252
BORDER:		EQU 254

EXECPAGE:	EQU 24
SETUPPAGE:	EQU 14


;
; Constants affecting animation.
;
WALK_FRAME_DURATION:		EQU 10

;
; Constants defining the coordinate system.
;
START_X:	EQU 64		; Offset of the left of the display in internal coordinates. Making this a multiple of 16 simplifies map collision detection.
START_Y:	EQU 48		; Offset of the top of the display in internal coordinates. Making this a multiple of 16 simplifies map collision detection.
Y_CEILING:	EQU 8		; Position at which player will bump his head in internal coordinate; needs to be more than 0 to avoid tunnelling.

	ORG 0
	DUMP EXECPAGE, 0
	AUTOEXEC

	; This program does not use interrupts.
	di

	; Disable display until setup is complete.
	ld a, %10000000
	out (BORDER), a

	; Establish line interrupts at line 191, which will be polled for later.
	ld a, 191
	out (LINE), a

	;
	; The SAM being what it is, execution will actually begin with this code in
	; the upper page.
	;
	; But that's convenient for taking advantage of the setup code â€” put that
	; initially into the lower page and give it a modified return address.
	;
	ld a, %00100000 + SETUPPAGE
	out (LMPR), a
	ld de, @+fix_page + 0x8000
	jp setup_per_screen_code

@fix_page:
	; Page self to lower page and proceed with execution from there.
	ld a, %00100000 + EXECPAGE
	out (LMPR), a

	; Do a full redraw at the current scroll position.
	ld de, @+enter_loop
	jp reset_scrolling
@enter_loop:

	; Reenable the display.
	ld a, %00000000
	out (BORDER), a

;
; Initial setup tasks are done now.
;
; With no title screen, etc, yet implemented, just jump straight to the in-game loop.
;
	jp game_loop



NUM_OBJECTS:		EQU 4		; Currently: allow at max four objects. Which is probably optimistic.

objects:
@object_content: 	EQU FOR NUM_OBJECTS
	dw 0, 0						; Object position.
	dw 0, 0						; Previous position.
	db 0						; Image. Set to 0 to disable object.
	call 0x1234					; Function pointer for 'update object'
	ds 4						; Spare storage, usable by update object function for state. Sized arbitrarily,
								; albeit that currently it neatly makes objects 16 bytes. Might grow or shrink later,
								; as I learn more about my actual usage.
NEXT @object_content

; Various offsets within an object.
Object.Position:			EQU 0
Object.PreviousPosition:	EQU 4
Object.Image:				EQU 8
Object.Call:				EQU 9
Object.OwnedState:			EQU 12
OBJECT_SIZE:				EQU 16

OBJECT_CULL_THRESHOLD:		EQU 32		; The number of byte columns an object must be beyond the edge of the screen
										; to be culled from the active list.

update_game_logic:
	;
	; Call update function on each and every active object.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+no_object

	; [Indirectly] call into the update function.
	jp @object + Object.Call

@no_object:
NEXT @test_object

	jp update_player_logic


did_scroll_left1:
	;
	; Update positions of all active objects.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	;
	; Increment position.
	;
	ld a, (@object + Object.Position + Position.x + 1)
	inc a
	ld (@object + Object.Position + Position.x + 1), a

	ld a, (@object + Object.PreviousPosition + Position.x + 1)
	inc a
	ld (@object + Object.PreviousPosition + Position.x + 1), a

@no_object:
NEXT @test_object

	ret


did_scroll_right1:
	;
	; Update positions of all active objects.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	;
	; Decrement position.
	;
	ld a, (@object + Object.Position + Position.x + 1)
	dec a
	ld (@object + Object.Position + Position.x + 1), a

	ld a, (@object + Object.PreviousPosition + Position.x + 1)
	dec a
	ld (@object + Object.PreviousPosition + Position.x + 1), a

@no_object:
NEXT @test_object
	ret


did_scroll_left8:
	; TODO: check event list potentially to spawn new objects.

	ret


did_scroll_right8:
	; TODO: check event list potentially to spawn new objects.

	ret


draw_objects:
	;
	; Draw all active objects.
	;
@test_object: EQU FOR NUM_OBJECTS
	@object: EQU objects + @test_object * OBJECT_SIZE
	ld a, (@object + Object.Image)
	or a
	jp z, @+next_object

	; Draw the object and mark dirty.
	ld h, a
	sub START_Y
	ld a, (@object + Object.Position + Position.y + 1)
	ld d, a
	ld a, (@object + Object.Position + Position.x + 1)

	;
	; Check whether position has crossed a threshold into being so far
	; off-screen that it is time to be culled.
	;

	cp START_X - 8 - OBJECT_CULL_THRESHOLD
	jp m, @+cull_object

	cp START_X + 128 + OBJECT_CULL_THRESHOLD
	jp p, @+cull_object

	;
	; Object isn't being culled; proceed with drawing.
	;
	call draw_clippable		; TODO: if this could return a flag indicating whether the object was drawn, some work
							; could be saved below?

	ld a, (@object + Object.Position + Position.x + 1)
	ld b, a
	ld a, (@object + Object.Position + Position.y + 1)
	ld c, a
	call clip_mark16x24
	jp @+next_object

@cull_object:
	xor a
	ld (@object + Object.Image), a

@next_object:
NEXT @test_object

	;
	; Draw player.
	;
	jp draw_player_sprite

; Code to include on the main program page.
INC "game_loop.z80s"
INC "generated/sprites.z80s"
INC "mark_dirty.z80s"
INC "player/display.z80s"
INC "player/logic.z80s"
INC "scrolling.z80s"

; Code that goes elsewhere.
INC "video_buffers/buffer_setup.z80s"
INC "generated/tiles.z80s"
