@hero_walk_count:	db 0	; Counts number of frames the player has been walking on the ground for, affecting current frame.

;
; Draws the hero sprite and flags appropriate dirty spots.
;
draw_hero_sprite:
	; Load y, subtract origin, multiply it by 128 and set the top bit.
	ld l, 0
	ld a, (hero_current+Y_OFFSET+1)
	sub START_Y
	scf
	rra
	rr l
	ld h, a

	; Add x.
	ld a, (hero_current+X_OFFSET+1)
	add l
	ld l, a

	; Call preformed sprite plotter.
	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+draw_jump

	ld a, (hero_flags)
	and FLAG_STATIONARY
	jr nz, @+draw_stationary

	ld a, (@hero_walk_count)
	inc a
	cp 4*WALK_FRAME_DURATION
	jr nz, @+pick_sprite

	ld a, 0
@pick_sprite:
	ld (@hero_walk_count), a

	; HACK: just hard code this for now.
	cp WALK_FRAME_DURATION
	jr nc, @+compare_next
	call sprite_0
	jr @+mark_dirty

@compare_next:
	cp 2*WALK_FRAME_DURATION
	jr nc, @+compare_next
	call sprite_1
	jr @+mark_dirty

@compare_next:
	cp 3*WALK_FRAME_DURATION
	jr nc, @+compare_next
	call sprite_2
	jr @+mark_dirty

@compare_next:
	call sprite_1
	jr @+mark_dirty

@draw_stationary:
	call sprite_3
	jr @+mark_dirty_reset

@draw_jump:
	call sprite_4

@mark_dirty_reset:
	; Zero out walk count, to resume at 0 upon next hitting the ground.
	xor a
	ld (@hero_walk_count), a

@mark_dirty:
	;
	; Mark proper dirty bits.
	;


	; Calculate first dirty column, multiplied by three.
	ld a, (scroll_offset)
	or a
	jr nz, @+not_zero
	add a, 16
@not_zero:
	rra

	ld e, a
	ld a, (hero_current+X_OFFSET+1)
	add e
	ld c, e

	and 0xf8
	rra
	rra
	ld e, a
	rra
	add e

	; Relocate into dirty flags.
	ld l, a
	ld h, DIRTY_FLAGS >> 8

	;
	; HL = first dirty flags byte for the column the sprite is in.
	;

	ld a, (hero_current+Y_OFFSET+1)
	sub START_Y
	ld b, 64
@search_down:
	cp b
	jr c, @+search_done
	sub b
	inc l
	jr @-search_down
@search_done:

	;
	; HL = first dirty byte flag that sprite actually touches, A = offset within byte.
	;

	and 0xf8		; Divide A by 16 and use bit 3 to decide whether code needs to mark
	rra				; three dirty bits, or only two.
	rra
	rra
	rra
	jr c, @+set_three

	;
	; If here: two bits need to be set, starting from the bit identified in A within
	; the byte pointed to by HL (and possibly again at HL+3, if x&15 is not zero).
	;

	ex de, hl
	ld hl, two_table
	add l
	ld l, a
	ld a, (hl)
	or a
	ex de, hl

	jr z, @+set_adjacent_two	; If the two bits to set overflow this byte, head elsewhere.

@touch_single_byte:
	or (hl)					; Set bits in this byte.
	ld (hl), a

	ld b, a					; Check whether another column needs to be touched.
	ld a, c
	and 0x0f
	ret z

	inc l					; Mark second column
	inc l
	inc l
	ld a, (hl)
	or b
	ld (hl), a
	ret

@set_adjacent_two:
	ld de, 0x2004

@set_adjacent:
	ld a, (hl)				; Set bit in this byte, and in next
	or e
	ld (hl), a
	inc l

	ld a, (hl)
	or d
	ld (hl), a

	ld a, c					; Check whether another column needs to be touched.
	and 0x0f
	ret z

	inc l					; Mark second column
	inc l
	ld a, (hl)
	or e
	ld (hl), a
	inc l
	ld a, (hl)
	or d
	ld (hl), a
	ret

@set_three:

	;
	; If here: three bits need to be set, starting from the bit identified in A within
	; the byte pointed to by HL (and possibly again at HL+3, if x&15 is not zero).
	;

	ex de, hl
	ld hl, three_table
	ld b, a
	add l
	ld l, a
	ld a, (hl)
	or a
	ex de, hl

	jr nz, @-touch_single_byte	; If the three bits to set fit within this byte, jump up.

	ld a, b
	cp 2
	jr z, @+split_2_1

	ld de, 0x3004
	jr @-set_adjacent

@split_2_1:
		
	ld de, 0x200c
	jr @-set_adjacent

	ret

two_table:		db 0x30, 0x18, 0x0c, 0x00
three_table:	db 0x38, 0x1c, 0x00, 0x00
