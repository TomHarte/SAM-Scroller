;
; Adopted coordinate system:
;
;	1 horizontal unit = 2 pixels.
;
;	This both means you can read it as a byte location and
;	it'll give enemies enough range to be able to move off both sides of the screen.
;	Since positions are in fixed point, it also doesn't obstruct true pixel-level placement
;	if I decide to support that.
;
;	Though I've still yet to hammer myself in on an origin. It probably should be that
;	[64, 192] is the visible area.
;
;
;	1 vertical unit = 1 pixels.
;
;	Since the screen is only 192 pixels high there are 64 off-screen pixels without
;	any further adjustment being necessary.
;
;	Right now I'm using position 248 as the bottom of the screen on the basis that
;	jumping over the top of the frame is standard platformer behaviour but dipping
;	below the bottom isn't so common. So that gives 8 rows below and 56 above.
;
hero_current:	dw 60 << 8, START_Y << 8
hero_previous:	dw 60 << 8, START_Y << 8
X_OFFSET:	EQU 0
Y_OFFSET:	EQU 2

hero_flags:		db 0	; Indicates current player status – which direction they're facing and whether they're on solid ground.

FLAG_DIRECTION:		EQU 1
FLAG_ON_GROUND:		EQU 2
FLAG_STATIONARY:	EQU 4

@hero_jump_count:	db 0	; Records how long the jump button has been acknowledged for; pressing for longer gives a higer jump.

update_game_logic:
	;
	; Vertical.
	;
	ld hl, (hero_current+Y_OFFSET)		; HL = current, BC = previous, and update in-memory copy of previous.
	ld bc, (hero_previous+Y_OFFSET)
	ld (hero_previous+Y_OFFSET), hl

	or a
	sbc hl, bc
	ld d, h
	ld e, l

@vertical_damp: EQU FOR VERTICAL_DAMPING
	sra d
	rr e
NEXT @vertical_damp
	or a
	sbc hl, de

	ex de, hl
	ld hl, (hero_current+Y_OFFSET)
	add hl, de						; Add difference to HL.

	ld bc, GRAVITY_STRENGTH			; Add some gravity.
	add hl, bc

	; Reset on-ground flag.
	ld a, (hero_flags)
	and ~FLAG_ON_GROUND
	ld (hero_flags), a

	; Test for bounds of screen.
	ld a, h
	cp START_Y + 192 - 24
	jr c, @+test_top

	; If here: is on ground.
	ld hl, (START_Y + 192 - 24) << 8
	ld a, (hero_flags)
	or FLAG_ON_GROUND
	ld (hero_flags), a

	jr @+store_y

@test_top:
	cp Y_CEILING
	jr nc, @+store_y
	ld hl, Y_CEILING << 8

@store_y:
	ld (hero_current+Y_OFFSET), hl

	;
	; Horizontal.
	;
	ld hl, (hero_current+X_OFFSET)		; HL = current, BC = previous, and update in-memory copy of previous.
	ld bc, (hero_previous+X_OFFSET)
	ld (hero_previous+X_OFFSET), hl

	or a
	sbc hl, bc
	ld d, h
	ld e, l

@ground_damping: EQU FOR HORIZONTAL_GROUND_DAMPING
	sra d
	rr e
NEXT @ground_damping

IF HORIZONTAL_AIR_DAMPING != HORIZONTAL_GROUND_DAMPING
	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr nz, @+no_air_damping

@air_damping: EQU FOR HORIZONTAL_AIR_DAMPING - HORIZONTAL_GROUND_DAMPING
	sra d
	rr e
NEXT @air_damping

@no_air_damping:
ENDIF

	; Set stationary flag depending on amount of movement.
	ld a, d
	or e
	jr nz, @+in_motion

	ld a, (hero_flags)
	or FLAG_STATIONARY
	ld (hero_flags), a
	jr @+apply_velocity

@in_motion:
	ld a, (hero_flags)
	and ~FLAG_STATIONARY
	ld (hero_flags), a

@apply_velocity:
	; If the result of shifting is a number that's zero then 
	; the original difference is below a meaningful threshold, 
	; so just don't apply anything.
	ld a, d
	or e
	jr z, @+zero_velocity

	sbc hl, de
	ex de, hl
	ld hl, (hero_current+X_OFFSET)
	add hl, de						; Add difference to HL.
	jr @+velocity_done

@zero_velocity:
	ld hl, (hero_current+X_OFFSET)

@velocity_done:
	; Do some left/right.
	ld bc, 0xfffe
	in a, (c)

	rra
	rra
	rra
	rra
	jr c, @+no_left

	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+apply_air_constant_left

@apply_ground_constant_left:
	ld bc, -HORIZONTAL_GROUND_STRENGTH
	add hl, bc

	jr @+no_right

@apply_air_constant_left:
	ld bc, -HORIZONTAL_AIR_STRENGTH
	add hl, bc

	jr @+no_right

@no_left:
	rra
	jr c, @+no_right

	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+apply_air_constant_right

@apply_ground_constant_right:
	ld bc, HORIZONTAL_GROUND_STRENGTH
	add hl, bc

	jr @+no_right

@apply_air_constant_right:
	ld bc, HORIZONTAL_AIR_STRENGTH
	add hl, bc

	;
	; TODO: better camera logic.
	;
	; I suspect something like "if facing left, try to keep sprite on right of screen" and vice versa.
	; The below just gives the sprite a certain boxed area around the centre of the screen, at the
	; edges of which he pushes the camera.
	;

@no_right:
	ld (hero_current+X_OFFSET), hl

	; Check whether player is requesting a jump.
	ld bc, 0x7ffe
	in a, (c)
	rra
	jr c, @+no_jump

	; If player is on the ground, definitely honour and reset the jump count.
	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+test_jump_count

	ld a, MAX_JUMP_FRAMES
	ld (@hero_jump_count), a
	jr @+apply_jump

@test_jump_count:
	; Still honour the jump if the button has been held continuously for MAX_JUMP_FRAMES or
	; fewer frames since the player was on the ground.
	ld a, (@hero_jump_count)
	or a
	jr z, @+no_jump

@apply_jump:
	ld a, (@hero_jump_count)
	dec a
	ld (@hero_jump_count), a

	ld hl, (hero_current+Y_OFFSET)
	ld bc, -JUMP_STRENGTH
	add hl, bc
	ld (hero_current+Y_OFFSET), hl
	jr @+did_jump

@no_jump:
	xor a
	ld (@hero_jump_count), a

@did_jump:
	; Check bounds and force a scroll if necessary.
	ld a, (hero_current+X_OFFSET+1)
	cp 64 + 16
	jr c, @+no_scroll_right

	call scroll_right
;	jr c, @+no_scroll_right			; TODO: in this case also check for right bounds of screen.

	ld a, (hero_current+X_OFFSET+1)
	dec a
	ld (hero_current+X_OFFSET+1), a

	ld a, (hero_previous+X_OFFSET+1)
	dec a
	ld (hero_previous+X_OFFSET+1), ax

	jr @+no_scroll_left

@no_scroll_right:
	ld a, (hero_current+X_OFFSET+1)
	cp 64 - 16
	jr nc, @+no_scroll_left

	call scroll_left
;	jr c, @+no_scroll_left			; TODO: in this case also check for left bounds of screen.

	ld a, (hero_current+X_OFFSET+1)
	inc a
	ld (hero_current+X_OFFSET+1), a

	ld a, (hero_previous+X_OFFSET+1)
	inc a
	ld (hero_previous+X_OFFSET+1), a

@no_scroll_left:
	ret

;
; I've never implemented a game like this before, so the following is an ad hoc attempt to
; reason about the proper approach to map collision detection.
;
; For me it's simplest to rationalise it as a Minkowski sum problem, i.e. to compare a player
; whose top left is at (px, py) with a tile whose top left is at (tx, ty) then:
;
; p_centre = (px, py) + (8, 12)
; t_centre = (tx, ty) + (8, 8)
; difference = p_centre - t_centre
;
; 'difference' then needs to be compared to a rectangle that runs from (-16, -20) to (16, 20):
;
;	* if it is outside those bounds then there is no overlap between player and block;
;	* if it inside those bounds then determine which outer edge it is nearest and move the
;		player by the distance from that edge;
;	* where distances are equal I feel like preferring motion upwards, then left/right, then down
;		is fairest to the player — it means that if they entered overlap on an exact diagonal
;		then the code most prefers giving them solid ground, but as a secondary preference it
;		doesn't interrupt an ongoing jump.
;
; As a first implementation I can just do that for all six tiles that the player potentially overlaps.
;
; Concretely:
;
;	difference	= (px, py) + (8, 12) - ((tx, ty) + (8, 8))
;				= (px, py) + (8, 12) - (tx, ty) - (8, 8)
;				= (px, py) - (tx, ty) + (0, 4)
;
; ... and compare that to (-16, -20) to (16, 20).
;
; Or eliminate the +4 and compare to (-16, -24) to (16, 16). Unless I've got the sign wrong
; somewhere, in which case it'd be a y of -16 to 24. If I have then I'm sure the mistake will
; reveal itself quickly.
;
; As a potential additional thought: the maximum runtime speeds that can be achieved could be used
; to fast-reject directions from consideration. I don't know whether that'll help.
;
; And, of course, the use above of implicit velocity — current and previous positions are stored,
; with velocity implicitly being the difference between the two — means that all I need to do is
; fix sprite position
;

;
; Noting as an aside: the current import tool always picks any old IDs it likes for tiles. This will
; need to change, but since I don't expect to spend my life generating maps from screen captures
; it's been low priority.
;
; That said, as a mere empirical fact, the current test for whether a tile is solid would appear
; to need to be:
;
;	tile == 2 || (tile >= 17 && tile <= 23)
;
; So that's a little bit of nonsense, but there it is.
;
