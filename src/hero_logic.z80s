;
; Adopted coordinate system:
;
;	1 horizontal unit = 2 pixels.
;
;	This both means you can read it as a byte location and
;	it'll give enemies enough range to be able to move off both sides of the screen.
;	Since positions are in fixed point, it also doesn't obstruct true pixel-level placement
;	if I decide to support that.
;
;	Though I've still yet to hammer myself in on an origin. It probably should be that
;	[64, 192] is the visible area.
;
;
;	1 vertical unit = 1 pixels.
;
;	Since the screen is only 192 pixels high there are 64 off-screen pixels without
;	any further adjustment being necessary.
;
;	Right now I'm using position 248 as the bottom of the screen on the basis that
;	jumping over the top of the frame is standard platformer behaviour but dipping
;	below the bottom isn't so common. So that gives 8 rows below and 56 above.
;
hero_current:	dw 64 << 8, START_Y << 8
hero_previous:	dw 64 << 8, START_Y << 8
X_OFFSET:	EQU 0
Y_OFFSET:	EQU 2

hero_flags:		db 0	; Indicates current player status – which direction they're facing and whether they're on solid ground.

FLAG_DIRECTION:		EQU 1
FLAG_ON_GROUND:		EQU 2
FLAG_STATIONARY:	EQU 4

SCREEN_TOP:			EQU START_Y	; TODO: if and when player sprite can safely go off top of screen, change this to Y_CEILING.

@hero_jump_count:	db 0	; Records how long the jump button has been acknowledged for; pressing for longer gives a higer jump.

update_game_logic:
	;
	; I've artificially split the following into separate steps for the time being,
	; to try to keep this code tractable as I have a much more nebulous sense of the
	; destination than with other code I have so far written.
	;
	call apply_inherent_forces
	call apply_input

	call reset_hero_flags
	call test_map_collisions
	call test_vertical_bounds
	jp test_horizontal_bounds





apply_input:
	;
	; Check whether player is requesting a jump.
	;
	ld bc, 0x7ffe
	in a, (c)
	rra
	jr c, @+no_jump

	; If player is on the ground, definitely honour and reset the jump count.
	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+test_jump_count

	ld a, MAX_JUMP_FRAMES
	ld (@hero_jump_count), a
	jr @+apply_jump

@test_jump_count:
	; Still honour the jump if the button has been held continuously for MAX_JUMP_FRAMES or
	; fewer frames since the player was on the ground.
	ld a, (@hero_jump_count)
	or a
	jr z, @+no_jump

@apply_jump:
	ld a, (@hero_jump_count)
	dec a
	ld (@hero_jump_count), a

	ld hl, (hero_current+Y_OFFSET)
	ld bc, -JUMP_STRENGTH
	add hl, bc
	ld (hero_current+Y_OFFSET), hl
	jr @+did_jump

@no_jump:
	xor a
	ld (@hero_jump_count), a

@did_jump:


	;
	; Check also for left/right input
	;
	; Check for horizontal motion.
	ld hl, (hero_current+X_OFFSET)
	ld bc, 0xfffe
	in a, (c)

	rra
	rra
	rra
	rra
	jr c, @+no_left

	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+apply_air_constant_left

@apply_ground_constant_left:
	ld bc, -HORIZONTAL_GROUND_STRENGTH
	add hl, bc

	jr @+no_right

@apply_air_constant_left:
	ld bc, -HORIZONTAL_AIR_STRENGTH
	add hl, bc

	jr @+no_right

@no_left:
	rra
	jr c, @+no_right

	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+apply_air_constant_right

@apply_ground_constant_right:
	ld bc, HORIZONTAL_GROUND_STRENGTH
	add hl, bc

	jr @+no_right

@apply_air_constant_right:
	ld bc, HORIZONTAL_AIR_STRENGTH
	add hl, bc

@no_right:
	ld (hero_current+X_OFFSET), hl
	ret


reset_hero_flags:
	ld a, (hero_flags)
	and ~FLAG_ON_GROUND
	ld (hero_flags), a
	ret


test_vertical_bounds:
	; Test for bottom of screen
	ld a, (hero_current+Y_OFFSET+1)
	cp START_Y + 192 - 24
	jr nc, @+collide_with_bottom

	; Test for top of screen
	cp SCREEN_TOP
	jr c, @+collide_with_top
	ret

@collide_with_bottom:
	; Player is at bottom of screen, so is on the ground.
	; Set bottom of screen as location and set the ON_GROUND flag.
	ld hl, (START_Y + 192 - 24) << 8
	ld (hero_current+Y_OFFSET), hl

	ld a, (hero_flags)
	or FLAG_ON_GROUND
	ld (hero_flags), a
	ret

@collide_with_top:
	; Player is at top of screen. Just set maximum position.
	ld hl, SCREEN_TOP << 8
	ld (hero_current+Y_OFFSET), hl
	ret




apply_inherent_forces:
	;
	; Vertical.
	;

	; Grab current and previous positions, overwriting the old value of
	; previous with the old value of current.
	ld hl, (hero_current+Y_OFFSET)
	ld bc, (hero_previous+Y_OFFSET)
	ld (hero_previous+Y_OFFSET), hl

	; Let DE = implied velocity.
	or a
	sbc hl, bc
	ld d, h
	ld e, l

	; Apply dampening forces (air resistance, I guess).
@vertical_damp: EQU FOR VERTICAL_DAMPING
	sra d
	rr e
NEXT @vertical_damp
	or a
	sbc hl, de

	ex de, hl
	ld hl, (hero_current+Y_OFFSET)
	add hl, de

	; Apply gravity.
	ld bc, GRAVITY_STRENGTH
	add hl, bc
	ld (hero_current+Y_OFFSET), hl

	;
	; Horizontal.
	;

	; As before, load current and previous positions, and overwrite
	; old previous with old current.
	ld hl, (hero_current+X_OFFSET)
	ld bc, (hero_previous+X_OFFSET)
	ld (hero_previous+X_OFFSET), hl

h_veloc:
	; Let DE = implied velocity.
	or a
	sbc hl, bc
	ld d, h
	ld e, l

	; Apply dampening forces.
	;
	; Unlike vertically there are two possible forces at play:
	; there's air resistance but also ground friction. Which is
	; dealt with fairly trivially as applying one degree of
	; damping if the player is in the air and an optionally
	; different one if the player is on the ground.
@ground_damping: EQU FOR HORIZONTAL_GROUND_DAMPING
	sra d
	rr e
NEXT @ground_damping

IF HORIZONTAL_AIR_DAMPING != HORIZONTAL_GROUND_DAMPING
	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr nz, @+no_air_damping

@air_damping: EQU FOR HORIZONTAL_AIR_DAMPING - HORIZONTAL_GROUND_DAMPING
	sra d
	rr e
NEXT @air_damping

@no_air_damping:
ENDIF

	; Up to here: HL is previous velocity, DE is amount to remove
	; due to dampening.

	; If DE is zero then velocity must be very small but underflow
	; is going to prevent it ever reaching 0. If so make it
	; effectively zero by not applying any velocity whatsoever.
	ld a, d
	or e
	ld a, (hero_flags)
	jr nz, @+in_motion

	or FLAG_STATIONARY
	ld (hero_flags), a
	ret

@in_motion:
	and ~FLAG_STATIONARY
	ld (hero_flags), a

	; Apply dampening factor to velocity and apply velocity to position.
	sbc hl, de
	ex de, hl
	ld hl, (hero_current+X_OFFSET)
	add hl, de
	ld (hero_current+X_OFFSET), hl
	ret



test_horizontal_bounds:
	; Check bounds and force a scroll if necessary.
	ld a, (hero_current+X_OFFSET+1)
	cp 64 + 16
	jr c, @+no_scroll_right

	call scroll_right
;	jr c, @+no_scroll_right			; TODO: in this case also check for right bounds of screen.

	ld a, (hero_current+X_OFFSET+1)
	dec a
	ld (hero_current+X_OFFSET+1), a

	ld a, (hero_previous+X_OFFSET+1)
	dec a
	ld (hero_previous+X_OFFSET+1), a

	jr @+no_scroll_left

@no_scroll_right:
	ld a, (hero_current+X_OFFSET+1)
	cp 64 - 16
	ret nc

	call scroll_left
;	jr c, @+no_scroll_left			; TODO: in this case also check for left bounds of screen.

	ld a, (hero_current+X_OFFSET+1)
	inc a
	ld (hero_current+X_OFFSET+1), a

	ld a, (hero_previous+X_OFFSET+1)
	inc a
	ld (hero_previous+X_OFFSET+1), a

@no_scroll_left:
	ret


;
; Begin map collision detection here.
;
test_map_collisions:
	; Get x position relative to map.
	ld a, (hero_current+X_OFFSET+1)
	ld b, a
	ld a, (scroll_offset)
	or a
	jr nz, @+not_zero
	add 16
@not_zero:
	rra
	add b

	; Mask off the bottom bits so that position is
	; tile location multiplied by 8; improve that to
	; multiplied by 12 to index into the tile map.
	and ~7
	ld b, a
	rra
	add b

	; Turn that into a column address.
	ld hl, (map_address)
	ld bc, -17*12	; i.e. locate entry for the cell in the top left of display.
	add hl, bc
	ld b, 0
	ld c, a
	add hl, bc

	; Shift down in search of first hit row.
	ld a, (hero_current+Y_OFFSET+1)
	sub START_Y
	and 0xf0
	rra
	rra
	rra
	rra
	ld c, a
	add hl, bc

	; HL should now point to the tile overlapping the top left of the hero.
	ld a, (hero_current+X_OFFSET+1)
	and 7
	jr z, @+test_single_column

	jr @+test_single_column		; TEMPORARY.

@test_two_columns:
	;
	; TODO: in this, the most likely case, the player is straddling two columns.
	; So test four or six tiles for collisions.
	;
	ld a, (hl)
	call @+is_solid
	jr c, @+no_top_left

	; Has collided with a block on the top left. Consider pushing either
	; down or to the right.
	ld a, (hero_current+Y_OFFSET+1)
	sub START_Y


@no_top_left:

	ret

@test_single_column:
	; This is the easy one; player is confined to a single 
	; column of the map.

	ld a, (hl)
	call @+is_solid
	jr c, @+no_down

	ld a, (hero_current+Y_OFFSET+1)
	and ~0xf
	add 0x10
	ld (hero_current+Y_OFFSET+1), a

	xor a
	ld (hero_current+Y_OFFSET), a

@no_down:
	ld a, (hero_current+Y_OFFSET+1)
	and 0xf
	cp 9					; Test for y > 8 within a block.
	jr c, @+step_single

	inc hl
@step_single:
	inc hl

	ld a, (hl)
	call @+is_solid
	jr c, @+no_up

	ld a, (hero_current+Y_OFFSET+1)
	add 24				; Add height.
	and 0xf
	ld b, a
	ld a, (hero_current+Y_OFFSET+1)
	sub b
	ld (hero_current+Y_OFFSET+1), a

	ld a, 0xff
	ld (hero_current+Y_OFFSET), a

	ld a, (hero_flags)
	or FLAG_ON_GROUND
	ld (hero_flags), a

@no_up:
	ret

; Returns carry clear if solid, set otherwise.
@is_solid:
	; Simplified test: a > 17 || a == 2
	cp 17 << 2
	ret nc

	cp 2 << 2
	jr z, @+ret_c

	scf
	ret

@ret_c:
	xor a
	ret	

;
; I've never implemented a game like this before, so the following is an ad hoc attempt to
; reason about the proper approach to map collision detection.
;
; For me it's simplest to rationalise it as a Minkowski sum problem, i.e. to compare a player
; whose top left is at (px, py) with a tile whose top left is at (tx, ty) then:
;
; p_centre = (px, py) + (8, 12)
; t_centre = (tx, ty) + (8, 8)
; difference = p_centre - t_centre
;
; 'difference' then needs to be compared to a rectangle that runs from (-16, -20) to (16, 20):
;
;	* if it is outside those bounds then there is no overlap between player and block;
;	* if it inside those bounds then determine which outer edge it is nearest and move the
;		player by the distance from that edge;
;	* where distances are equal I feel like preferring motion upwards, then left/right, then down
;		is fairest to the player — it means that if they entered overlap on an exact diagonal
;		then the code most prefers giving them solid ground, but as a secondary preference it
;		doesn't interrupt an ongoing jump.
;
; As a first implementation I can just do that for all six tiles that the player potentially overlaps.
;
; Concretely:
;
;	difference	= (px, py) + (8, 12) - ((tx, ty) + (8, 8))
;				= (px, py) + (8, 12) - (tx, ty) - (8, 8)
;				= (px, py) - (tx, ty) + (0, 4)
;
; ... and compare that to (-16, -20) to (16, 20).
;
; Or eliminate the +4 and compare to (-16, -24) to (16, 16). Unless I've got the sign wrong
; somewhere, in which case it'd be a y of -16 to 24. If I have then I'm sure the mistake will
; reveal itself quickly.
;
; As a potential additional thought: the maximum runtime speeds that can be achieved could be used
; to fast-reject directions from consideration. I don't know whether that'll help.
;
; And, of course, the use above of implicit velocity — current and previous positions are stored,
; with velocity implicitly being the difference between the two — means that all I need to do is
; fix sprite position
;

;
; Postscript: with further reflection on the above, I think the following is appropriate:
;
;	(1)	determine how far right the player would need to be pushed if he overlaps anything
;		in the left column;
;	(2) determine how far left the player would need to be pushed if he overlaps anything
;		in the right column;
;	(3)	determine how far up the player would need to be pushed if he overlaps anything in
;		the bottom row, whether it's second or third;
;	(4)	determine how far down the player would need to be pushed if he overlaps anything
;		in the top row.
;
; Then, if the top-left square is filled, push the player whichever is the lesser of the
; right and down quantities. If there is a middle-left square and it is filled, push the
; player to the right. If the bottom-left square is filed, push the player to the lesser
; of the right and up quantities.
;
; And, if the player overlaps a second column, do the same thing there but comparing to
; the left quantity rather than the right.
;

;
; Noting as an aside: the current import tool always picks any old IDs it likes for tiles. This will
; need to change, but since I don't expect to spend my life generating maps from screen captures
; it's been low priority.
;
; That said, as a mere empirical fact, the current test for whether a tile is solid would appear
; to need to be:
;
;	tile == 2 || (tile >= 17 && tile <= 23)
;
; So that's a little bit of nonsense, but there it is.
;
