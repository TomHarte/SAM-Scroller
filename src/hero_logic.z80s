;
; Adopted coordinate system:
;
;	1 horizontal unit = 2 pixels.
;
;	This both means you can read it as a byte location and
;	it'll give enemies enough range to be able to move off both sides of the screen.
;	Since positions are in fixed point, it also doesn't obstruct true pixel-level placement
;	if I decide to support that.
;
;	Though I've still yet to hammer myself in on an origin. It probably should be that
;	[64, 192] is the visible area.
;
;
;	1 vertical unit = 1 pixels.
;
;	Since the screen is only 192 pixels high there are 64 off-screen pixels without
;	any further adjustment being necessary.
;
;	Right now I'm using position 248 as the bottom of the screen on the basis that
;	jumping over the top of the frame is standard platformer behaviour but dipping
;	below the bottom isn't so common. So that gives 8 rows below and 56 above.
;
hero_current:	dw 64 << 8, START_Y << 8
hero_previous:	dw 64 << 8, START_Y << 8
X_OFFSET:	EQU 0
Y_OFFSET:	EQU 2

hero_flags:		db 0	; Indicates current player status â€“ which direction they're facing and whether they're on solid ground.

FLAG_DIRECTION:		EQU 1
FLAG_ON_GROUND:		EQU 2
FLAG_STATIONARY:	EQU 4

SCREEN_TOP:			EQU START_Y	; TODO: if and when player sprite can safely go off top of screen, change this to Y_CEILING.

@hero_jump_count:	db 0	; Records how long the jump button has been acknowledged for; pressing for longer gives a higer jump.

update_game_logic:
	;
	; I've artificially split the following into separate steps for the time being,
	; to try to keep this code tractable as I have a much more nebulous sense of the
	; destination than with other code I have so far written.
	;
	call apply_inherent_forces
	call apply_input

	call reset_hero_flags
	call test_map_collisions
	call test_vertical_bounds
	jp test_horizontal_bounds





apply_input:
	;
	; Check whether player is requesting a jump.
	;
	ld bc, 0x7ffe
	in a, (c)
	rra
	jr c, @+no_jump

	; If player is on the ground, definitely honour and reset the jump count.
	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+test_jump_count

	ld a, MAX_JUMP_FRAMES
	ld (@hero_jump_count), a
	jr @+apply_jump

@test_jump_count:
	; Still honour the jump if the button has been held continuously for MAX_JUMP_FRAMES or
	; fewer frames since the player was on the ground.
	ld a, (@hero_jump_count)
	or a
	jr z, @+no_jump

@apply_jump:
	ld a, (@hero_jump_count)
	dec a
	ld (@hero_jump_count), a

	ld hl, (hero_current+Y_OFFSET)
	ld bc, -JUMP_STRENGTH
	add hl, bc
	ld (hero_current+Y_OFFSET), hl
	jr @+did_jump

@no_jump:
	xor a
	ld (@hero_jump_count), a

@did_jump:


	;
	; Check also for left/right input
	;
	; Check for horizontal motion.
	ld hl, (hero_current+X_OFFSET)
	ld bc, 0xfffe
	in a, (c)

	rra
	rra
	rra
	rra
	jr c, @+no_left

	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+apply_air_constant_left

@apply_ground_constant_left:
	ld bc, -HORIZONTAL_GROUND_STRENGTH
	add hl, bc

	jr @+no_right

@apply_air_constant_left:
	ld bc, -HORIZONTAL_AIR_STRENGTH
	add hl, bc

	jr @+no_right

@no_left:
	rra
	jr c, @+no_right

	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr z, @+apply_air_constant_right

@apply_ground_constant_right:
	ld bc, HORIZONTAL_GROUND_STRENGTH
	add hl, bc

	jr @+no_right

@apply_air_constant_right:
	ld bc, HORIZONTAL_AIR_STRENGTH
	add hl, bc

@no_right:
	ld (hero_current+X_OFFSET), hl
	ret


reset_hero_flags:
	ld a, (hero_flags)
	and ~FLAG_ON_GROUND
	ld (hero_flags), a
	ret


test_vertical_bounds:
	; Test for bottom of screen
	ld a, (hero_current+Y_OFFSET+1)
	cp START_Y + 192 - 24
	jr nc, @+collide_with_bottom

	; Test for top of screen
	cp SCREEN_TOP
	jr c, @+collide_with_top
	ret

@collide_with_bottom:
	; Player is at bottom of screen, so is on the ground.
	; Set bottom of screen as location and set the ON_GROUND flag.
	ld hl, (START_Y + 192 - 24) << 8
	ld (hero_current+Y_OFFSET), hl

	ld a, (hero_flags)
	or FLAG_ON_GROUND
	ld (hero_flags), a
	ret

@collide_with_top:
	; Player is at top of screen. Just set maximum position.
	ld hl, SCREEN_TOP << 8
	ld (hero_current+Y_OFFSET), hl
	ret




apply_inherent_forces:
	;
	; Vertical.
	;

	; Grab current and previous positions, overwriting the old value of
	; previous with the old value of current.
	ld hl, (hero_current+Y_OFFSET)
	ld bc, (hero_previous+Y_OFFSET)
	ld (hero_previous+Y_OFFSET), hl

	; Let DE = implied velocity.
	or a
	sbc hl, bc
	ld d, h
	ld e, l

	; Apply dampening forces (air resistance, I guess).
@vertical_damp: EQU FOR VERTICAL_DAMPING
	sra d
	rr e
NEXT @vertical_damp
	or a
	sbc hl, de

	ex de, hl
	ld hl, (hero_current+Y_OFFSET)
	add hl, de

	; Apply gravity.
	ld bc, GRAVITY_STRENGTH
	add hl, bc
	ld (hero_current+Y_OFFSET), hl

	;
	; Horizontal.
	;

	; As before, load current and previous positions, and overwrite
	; old previous with old current.
	ld hl, (hero_current+X_OFFSET)
	ld bc, (hero_previous+X_OFFSET)
	ld (hero_previous+X_OFFSET), hl

h_veloc:
	; Let DE = implied velocity.
	or a
	sbc hl, bc
	ld d, h
	ld e, l

	; Apply dampening forces.
	;
	; Unlike vertically there are two possible forces at play:
	; there's air resistance but also ground friction. Which is
	; dealt with fairly trivially as applying one degree of
	; damping if the player is in the air and an optionally
	; different one if the player is on the ground.
@ground_damping: EQU FOR HORIZONTAL_GROUND_DAMPING
	sra d
	rr e
NEXT @ground_damping

IF HORIZONTAL_AIR_DAMPING != HORIZONTAL_GROUND_DAMPING
	ld a, (hero_flags)
	and FLAG_ON_GROUND
	jr nz, @+no_air_damping

@air_damping: EQU FOR HORIZONTAL_AIR_DAMPING - HORIZONTAL_GROUND_DAMPING
	sra d
	rr e
NEXT @air_damping

@no_air_damping:
ENDIF

	; Up to here: HL is previous velocity, DE is amount to remove
	; due to dampening.

	; If DE is zero then velocity must be very small but underflow
	; is going to prevent it ever reaching 0. If so make it
	; effectively zero by not applying any velocity whatsoever.
	ld a, d
	or e
	ld a, (hero_flags)
	jr nz, @+in_motion

	or FLAG_STATIONARY
	ld (hero_flags), a
	ret

@in_motion:
	and ~FLAG_STATIONARY
	ld (hero_flags), a

	; Apply dampening factor to velocity and apply velocity to position.
	sbc hl, de
	ex de, hl
	ld hl, (hero_current+X_OFFSET)
	add hl, de
	ld (hero_current+X_OFFSET), hl
	ret



test_horizontal_bounds:
	; Test edge-of-screen bounds first, as these apply in absolute terms.
	ld a, (hero_current+X_OFFSET+1)
	cp 128 - 8 + 1
	jr c, @+no_constrain_right

	cp 128 + 64 - 8				; In which case the proper bounds are on the left.
	jr nc, @+constrain_left

	ld a, 128 - 8
	ld (hero_current+X_OFFSET+1), a
	ld a, 0xff
	ld (hero_current+X_OFFSET), a
	jr @+edges_done

@no_constrain_right:
	or a
	jp p, @+edges_done

@constrain_left:
	xor a
	ld (hero_current+X_OFFSET+1), a
	ld (hero_current+X_OFFSET), a

@edges_done:
	; Check bounds and force a scroll if necessary.
	ld a, (hero_current+X_OFFSET+1)
	cp 64 + 16 - 8
	jr c, @+no_scroll_right

	call scroll_right
	jr c, @+no_scroll_right

	ld a, (hero_current+X_OFFSET+1)
	dec a
	ld (hero_current+X_OFFSET+1), a

	ld a, (hero_previous+X_OFFSET+1)
	dec a
	ld (hero_previous+X_OFFSET+1), a

@no_scroll_right:
	ld a, (hero_current+X_OFFSET+1)
	cp 64 - 16
	ret nc

	call scroll_left
	ret c

	ld a, (hero_current+X_OFFSET+1)
	inc a
	ld (hero_current+X_OFFSET+1), a

	ld a, (hero_previous+X_OFFSET+1)
	inc a
	ld (hero_previous+X_OFFSET+1), a

	ret


;
; Begin map collision detection here.
;
test_map_collisions:
	; Get x position relative to map.
	ld a, (hero_current+X_OFFSET+1)
	ld b, a
	ld a, (scroll_offset)
	or a
	jr nz, @+not_zero
	add 16
@not_zero:
	rra
	add b

	; Mask off the bottom bits so that position is
	; tile location multiplied by 8; improve that to
	; multiplied by 12 to index into the tile map.
	and ~7
	ld b, a
	rra
	add b

	; Turn that into a column address.
	ld hl, (map_address)
	ld bc, -17*12	; i.e. locate entry for the cell in the top left of display.
	add hl, bc
	ld b, 0
	ld c, a
	add hl, bc

	; Shift down in search of first hit row.
	ld a, (hero_current+Y_OFFSET+1)
	sub START_Y
	and 0xf0
	rra
	rra
	rra
	rra
	ld c, a
	add hl, bc		; HL should now point to the tile overlapping the top left of the hero.

	; Store a backup of HL.
	ld d, h
	ld e, l

	; Test direction of vertical velocity; if none then no need to test
	; for overlaps. If upward, test top row. Otherwise test bottom row.
start_vertical_tests:
	ld hl, (hero_current+Y_OFFSET)
	ld bc, (hero_previous+Y_OFFSET)
	or a
	sbc hl, bc

	ld h, d
	ld l, e

	jr z, @+no_vertical_motion
	jp m, @+test_above
	
	; Vertical velocity is downward. Test for overlap at feet.
	; Task one: determine which map square contain the feet.
	ld a, (hero_current+Y_OFFSET+1)
	and 0xf
	cp 8
	jr c, @+no_middle
	inc hl
@no_middle:
	inc hl

	ld a, (hl)
	call @+is_solid
	jr nc, @+push_up

	; If there's no second column to check, don't check it.
	ld a, (hero_current+X_OFFSET+1)
	add a
	ld b, a
	ld a, (scroll_offset)
	add b
	and 0xf
	jr z, @+no_vertical_motion

	; Check seccond column.
	ld bc, 12
	add hl, bc
	ld a, (hl)
	call @+is_solid
	jr c, @+no_vertical_motion

@push_up:
	; Set on-ground flag.
	ld a, (hero_flags)
	or FLAG_ON_GROUND
	ld (hero_flags), a

	; Push player up above platform below.
	ld a, (hero_current+Y_OFFSET+1)
	add 8
	and ~0xf
	sub 8
	ld (hero_current+Y_OFFSET+1), a

	xor a
	ld (hero_current+Y_OFFSET), a
	jr @+no_vertical_motion

@test_above:
	; Vertical velocity is upnward. Test for overlap at head.
	ld a, (hl)
	call @+is_solid
	jr nc, @+push_down

	; If there's no second column to check, don't check it.
	ld a, (hero_current+X_OFFSET+1)
	add a
	ld b, a
	ld a, (scroll_offset)
	add b
	and 0xf
	jr z, @+no_vertical_motion

	; Check seccond column.
	ld bc, 12
	add hl, bc
	ld a, (hl)
	call @+is_solid
	jr c, @+no_vertical_motion

@push_down:
	; Push player down below platform above.
	ld a, (hero_current+Y_OFFSET+1)
	and ~0xf
	add 0x10
	ld (hero_current+Y_OFFSET+1), a
	xor a
	ld (hero_current+Y_OFFSET), a

@no_vertical_motion:

	; Test direction of horizontal velocity; if noen then no need to
	; test for overlaps. Ditto if player is exactly aligned with a
	; column, no need to test for horizontal overlaps. Otherwise
	; either test to the left or to the right depending on
	; sign of velocity.
start_horizontal_tests:
	ld a, (hero_current+X_OFFSET+1)
	add a
	ld b, a
	ld a, (scroll_offset)
	add b
	and 0xf
	jr z, @+no_horizontal_motion

	ld hl, (hero_current+X_OFFSET)
	ld bc, (hero_previous+X_OFFSET)
	or a
	sbc hl, bc

	ld h, d
	ld l, e

	jr z, @+no_horizontal_motion
	jp m, @+test_left

	; Horizontal velocity is rightward. Test for overlap to right.
	ld bc, 12
	add hl, bc

	ld a, (hl)
	call @+is_solid
	jr nc, @+push_left

	inc hl
	ld a, (hl)
	call @+is_solid
	jr nc, @+push_left

	ld a, (hero_current+Y_OFFSET+1)
	and 0xf
	cp 9
	jr c, @+no_horizontal_motion

	inc hl
	ld a, (hl)
	call @+is_solid
	jr c, @+no_horizontal_motion

@push_left:
	ld a, (scroll_offset)
	ld b, a

	ld a, (hero_current+X_OFFSET+1)
	add a

	add b
	and ~0xf
	sub b

	rra
	ld (hero_current+X_OFFSET+1), a
	ld a, 0xff
	ld (hero_current+X_OFFSET), a

	jr @+no_horizontal_motion

@test_left:
	ld a, (hl)
	call @+is_solid
	jr nc, @+push_right

	inc hl
	ld a, (hl)
	call @+is_solid
	jr nc, @+push_right

	ld a, (hero_current+Y_OFFSET+1)
	and 0xf
	cp 9
	jr c, @+no_horizontal_motion

	inc hl
	ld a, (hl)
	call @+is_solid
	jr c, @+no_horizontal_motion

@push_right:
	ld a, (scroll_offset)
	ld b, a
	ld a, (hero_current+X_OFFSET+1)
	add a

	add b
	and ~0xf
	add 16
	sub b

	rra
	ld (hero_current+X_OFFSET+1), a
	xor a
	ld (hero_current+X_OFFSET), a

@no_horizontal_motion:
	ret


; Returns carry clear if solid, set otherwise.
@is_solid:
	; Simplified test: a > 17 || a == 2
	cp 17 << 2
	ret nc

	cp 2 << 2
	jr z, @+ret_c

	scf
	ret

@ret_c:
	xor a
	ret	
